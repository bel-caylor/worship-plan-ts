<script>
  function weeklyPlanApp() {
    const IS_GUEST = !!(window.__GUEST__);
    return {
      isGuest: IS_GUEST,
      showDetails: false,
      showOrder: false,
      activeContentTab: 'scripture',
      loadingServices: true,
      loadingOrder: false,
      // cache + persistence
      loadedOnce: false,
      existingServices: [],
      selectedServiceId: '',
      leaderChoices: [],
      preacherChoices: [],
      leaderSelect: '',
      preacherSelect: '',
      books: [],
      scripture: { book: 'John', chapter: 3, start: '1', end: '' },
      scriptureText: '',
      orderItemTypes: [],
      orderRows: [],
      teamAssignments: [],
      teamAssignmentsLoading: false,
      teamAssignmentsError: '',
      teamAssignmentsSupported: true,
      teamAssignmentsUnsupportedReason: '',
      // service detail autosave
      savingDetails: false,
      saveDetailsTimer: null,
      detailsError: '',
      detailsDirty: false,
      // order autosave state
      savingOrder: false,
      saveOrderTimer: null,
      saveOrderError: '',
      savedAt: 0,
      suggestOpenIndex: -1,
      suggestions: [],
      // for scripture suggestions inline dropdown
      scriptureSuggestIndex: -1,
      scriptureSuggestions: [],
      showScriptureModal: false,
      selectedScriptureRef: '',
      selectedScriptureText: '',
      selectedScriptureHtml: '',
      _passageCache: {},
      isScriptureEditing: false,
      isScriptureEditing: false,
      scriptureSearchTheme: '',
      scriptureSearchKeywords: '',
      scriptureSearchPrimary: '',
      scriptureSearchPending: false,
      scriptureSearchError: '',
      _refTimer: null,
      showSuggestModal: false,
      suggestTargetIndex: -1,
      loadingSuggestion: false,
      recommendedSongs: [],
      recommendedSongsError: '',
      recommendedSongsLoading: false,
      recommendedSongIndex: -1,
      embeddedSongsInstance: null,
      form: { id: '', date: '', time: '', type: '', leader: '', preacher: '', scripture: '', theme: '', keywords: '', notes: '', suggestedSongs: '' },
      showCreateServicesModal: false,
      batchStartDate: '',
      batchWeeks: 12,
      batchCreateLoading: false,
      batchCreateError: '',

      init() {
        const ctx = (window.APP_CTX || {});
        const defs = ctx.defaults || {};
        this.books = Array.isArray(ctx.bibleBooks) ? ctx.bibleBooks : [];
        this.orderItemTypes = Array.isArray(ctx.orderItemTypes) ? ctx.orderItemTypes : ['Welcome', 'Call To Worship', 'Song', 'Sermon', 'Communion', 'Offering', 'Announcements', 'Benediction'];
        this.leaderChoices = Array.isArray(ctx.leaderChoices) ? ctx.leaderChoices.slice() : ['Darden', 'Belinda', 'Lois'];
        const ctxPreacherChoices = Array.isArray(ctx.preacherChoices) ? ctx.preacherChoices : ctx.sermonChoices;
        this.preacherChoices = Array.isArray(ctxPreacherChoices) ? ctxPreacherChoices.slice() : ['Tom', 'Darden', 'Miguel', 'Alfredo'];

        this.form.date = this.nextSundayISO();
        this.form.time = defs.time || '10:00 AM';
        this.form.type = defs.serviceType || 'Worship';
        this.form.leader = defs.leader || 'Darden';
        this.form.preacher = defs.sermon || defs.preacher || 'Tom';
        this.leaderSelect = this.form.leader;
        this.preacherSelect = this.form.preacher;
        this.ensureSuggestStore();
        this.loadingServices = true;
        // Restore previously selected service id if present
        try { this.selectedServiceId = localStorage.getItem('wp.selectedServiceId') || ''; } catch (_) { }

        (async () => {
          try {
            const r = await callRpc('getServicePeople', null);
            if (r?.leaders) this.leaderChoices = Array.from(new Set([...this.leaderChoices, ...r.leaders])).sort((a, b) => a.localeCompare(b));
            if (r?.preachers) this.preacherChoices = Array.from(new Set([...this.preacherChoices, ...r.preachers])).sort((a, b) => a.localeCompare(b));
          } catch (e) { /* ignore */ }
          try {
            // Use server-injected services immediately, else localStorage cache
            if (Array.isArray(window.__SERVICES__) && window.__SERVICES__.length) {
              this.existingServices = window.__SERVICES__;
            } else {
              let cached = null; try { cached = JSON.parse(localStorage.getItem('wp.servicesCache') || 'null'); } catch (_) { }
              if (cached && Array.isArray(cached.items) && (Date.now() - (cached.ts || 0) < 300000)) { // 5 min TTL
                this.existingServices = cached.items;
              }
            }
            let loadedViaRpc = false;
            try {
              const s = await callRpc('listServices', null);
              if (Array.isArray(s?.items)) {
                this.existingServices = s.items;
                loadedViaRpc = true;
              }
            } catch (_) {
              // Guest mode or RPC unavailable: keep injected/cache data
            }
            if (!Array.isArray(this.existingServices) || !this.existingServices.length) {
              this.newService();
            } else if (this.selectedServiceId && !this.detailsDirty) {
              const refreshed = this.existingServices.find(svc => svc && svc.id === this.selectedServiceId);
              if (refreshed) this.applyServiceDetails(refreshed, { force: true, focus: false });
            }
            if (loadedViaRpc) {
              try { localStorage.setItem('wp.servicesCache', JSON.stringify({ ts: Date.now(), items: this.existingServices })); } catch (_) { }
            }
          } catch (_) { /* ignore */ }
          this.ensureDefaults();
          // Normalize any "Custom" labels in dropdowns (in case of encoding artifacts)
          this.$nextTick(() => {
            try { document.querySelectorAll('option[value="__custom"]').forEach(o => o.textContent = 'CustomGÇª'); } catch (_) { }
          });
          // Auto-load previously selected service if available
          this.$nextTick(() => {
            try {
              if (!this.selectedServiceId) {
                // nothing selected yet; stay blank
                return;
              }
              // Ensure the selected ID actually exists before loading; otherwise clear it.
              const existsNow = Array.isArray(this.existingServices) && this.existingServices.some(svc => svc?.id === this.selectedServiceId);
              if (existsNow) {
                this.loadSelected();
              } else {
                this.selectedServiceId = '';
                try { localStorage.removeItem('wp.selectedServiceId'); } catch (_) { }
              }
            } catch (_) { }
          });
        })().finally(() => { this.loadingServices = false; });
        try {
          window.addEventListener('embedded-songs-ready', (evt) => {
            const inst = evt && evt.detail && evt.detail.instance;
            if (inst) {
              this.embeddedSongsInstance = inst;
              this.applySongsBrowserAiFilter();
            }
          });
        } catch (_) { /* ignore */ }
      },

      ensureSuggestStore() {
        try {
          if (!window.Alpine || typeof window.Alpine.store !== 'function') return;
          if (!window.Alpine.store('suggestDefaults')) {
            window.Alpine.store('suggestDefaults', {
              seed: '',
              leader: '',
              usage: '',
              allowChristmas: true,
              updatedAt: 0
            });
          }
        } catch (_) { }
      },

      updateSuggestDefaults(index = this.suggestTargetIndex) {
        try {
          if (!window.Alpine || typeof window.Alpine.store !== 'function') return;
          if (!window.Alpine.store('suggestDefaults')) this.ensureSuggestStore();
          const store = window.Alpine.store('suggestDefaults');
          if (!store) return;
          const seed = [this.form.theme || '', this.form.keywords || '']
            .map(s => String(s || '').trim())
            .filter(Boolean)
            .join(', ');
          const row = index != null && index >= 0 ? this.orderRows[index] : null;
          const payload = {
            seed,
            leader: String(this.form.leader || ''),
            usage: this.usageFromItemType(String(row?.itemType || '')),
            allowChristmas: this.isAdventChristmas(this.form.date),
            updatedAt: Date.now()
          };
          Object.assign(store, payload);
        } catch (_) { }
      },

      nextSundayISO() {
        const now = new Date();
        const day = now.getDay();
        const add = (7 - day) % 7 || 7; // upcoming Sunday
        const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() + add);
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const dd = String(d.getDate()).padStart(2, '0');
        return `${y}-${m}-${dd}`;
      },

      // Find the last service date in the Services sheet and return the following Sunday (ISO)
      nextServiceDateFromExistingISO() {
        try {
          if (!Array.isArray(this.existingServices) || this.existingServices.length === 0) return this.nextSundayISO();
          // existingServices are sorted by ServiceID desc; try first with a valid date
          let latest = null;
          for (const s of this.existingServices) {
            const ds = String(s?.date || '').trim();
            if (!/^\d{4}-\d{2}-\d{2}$/.test(ds)) continue;
            const [y, m, d] = ds.split('-').map(Number);
            const dt = new Date(y, m - 1, d);
            if (!latest || dt > latest) latest = dt;
          }
          if (!latest) return this.nextSundayISO();
          // add 7 days to get the next Sunday after the latest
          const nxt = new Date(latest.getFullYear(), latest.getMonth(), latest.getDate() + 7);
          const y = nxt.getFullYear();
          const m = String(nxt.getMonth() + 1).padStart(2, '0');
          const dd = String(nxt.getDate()).padStart(2, '0');
          return `${y}-${m}-${dd}`;
        } catch (_) {
          return this.nextSundayISO();
        }
      },

      // Determine default service type from an ISO date string.
      // Communion on 1st, 3rd, 5th Sundays; Offering on 2nd and 4th.
      defaultServiceTypeForDateISO(iso) {
        try {
          if (!/^\d{4}-\d{2}-\d{2}$/.test(String(iso))) return 'Offering';
          const [y, m, d] = String(iso).split('-').map(Number);
          const dt = new Date(y, m - 1, d);
          // nth week index within the month (1..5)
          const nth = Math.floor((dt.getDate() - 1) / 7) + 1;
          return (nth === 1 || nth === 3 || nth === 5) ? 'Communion' : 'Offering';
        } catch (_) {
          return 'Offering';
        }
      },

      openCreateServicesModal() {
        this.batchCreateError = '';
        const next = this.nextServiceDateFromExistingISO();
        this.batchStartDate = /^\d{4}-\d{2}-\d{2}$/.test(String(this.batchStartDate || '')) ? this.batchStartDate : next;
        if (!this.batchStartDate) this.batchStartDate = next;
        if (!this.batchWeeks || this.batchWeeks < 1) this.batchWeeks = 12;
        this.showCreateServicesModal = true;
        this.$nextTick(() => {
          try { this.$refs.batchWeeks?.focus(); } catch (_) { }
        });
      },

      closeCreateServicesModal() {
        if (this.batchCreateLoading) return;
        this.showCreateServicesModal = false;
      },

      async submitBatchCreate() {
        const start = String(this.batchStartDate || '').trim();
        const weeks = Number(this.batchWeeks) || 0;
        if (!/^\d{4}-\d{2}-\d{2}$/.test(start)) {
          this.batchCreateError = 'Select a valid start Sunday (YYYY-MM-DD).';
          return;
        }
        if (weeks < 1) {
          this.batchCreateError = 'Enter how many weeks to create.';
          return;
        }
        this.batchCreateLoading = true;
        this.batchCreateError = '';
        try {
          const res = await callRpc('createServicesBatch', { startDate: start, weeks });
          const created = Array.isArray(res?.created) ? res.created : [];
          if (created.length) {
            notify(`Created ${created.length} new service${created.length === 1 ? '' : 's'}.`, 'success');
          } else {
            notify('All requested services already exist.', 'info');
          }
          await this.refreshServices();
          this.showCreateServicesModal = false;
        } catch (e) {
          console.error(e);
          const msg = (e && e.message) ? e.message : 'Unable to create services';
          this.batchCreateError = msg;
          notify(msg, 'error');
        } finally {
          this.batchCreateLoading = false;
        }
      },

      async refreshServices() {
        this.loadingServices = true;
        try {
          const s = await callRpc('listServices', null);
          this.existingServices = Array.isArray(s?.items) ? s.items : [];
          try { localStorage.setItem('wp.servicesCache', JSON.stringify({ ts: Date.now(), items: this.existingServices })); } catch (_) { }
        } catch (err) {
          console.error(err);
        } finally {
          this.loadingServices = false;
        }
      },

      newService() {
        const ctx = (window.APP_CTX || {}); const d = ctx.defaults || {};
        try {
          if (this.saveDetailsTimer) {
            clearTimeout(this.saveDetailsTimer);
            this.saveDetailsTimer = null;
          }
        } catch (_) { }
        this.detailsDirty = false;
        this.detailsError = '';
        this.savingDetails = false;
        this.selectedServiceId = '';
        const nextDate = this.nextServiceDateFromExistingISO();
        const defType = this.defaultServiceTypeForDateISO(nextDate);
        this.form = { id: '', date: nextDate, time: (d.time || '10:00 AM'), type: defType, leader: (d.leader || 'Darden'), preacher: (d.preacher || d.sermon || 'Tom'), scripture: '', theme: '', keywords: '', notes: '', suggestedSongs: '' };
        this.ensureDefaults();
        this.scripture = { book: 'John', chapter: 3, start: '1', end: '' };
        this.form.scripture = '';
        this.scriptureText = '';
        this.orderRows = [];
        this.showOrder = false;
        this.activeContentTab = 'scripture';
        this.showDetails = true;
        this.resetTeamAssignments();
        this.resetRecommendations();
        this.$nextTick(() => {
          if (this.$refs.dateInput) try { this.$refs.dateInput.focus(); } catch (_) { }
        });
        this.$nextTick(() => this.applySongsBrowserAiFilter());
      },

      async deleteSelectedService() {
        try {
          const id = String(this.selectedServiceId || '').trim();
          if (!id) { notify('Select a service first', 'info'); return; }
          if (!confirm('Delete this service and its order?')) return;
          await callRpc('deleteService', { id });
          // Refresh list
          this.loadingServices = true;
          try {
            const s = await callRpc('listServices', null);
            this.existingServices = Array.isArray(s?.items) ? s.items : this.existingServices;
          } catch (_) { /* ignore */ } finally {
            this.loadingServices = false;
          }
          // Clear current form
          this.selectedServiceId = '';
          this.form = { id: '', date: this.nextSundayISO(), time: (window.APP_CTX?.defaults?.time || '10:00 AM'), type: (window.APP_CTX?.defaults?.serviceType || 'Worship'), leader: (window.APP_CTX?.defaults?.leader || ''), preacher: (window.APP_CTX?.defaults?.preacher || window.APP_CTX?.defaults?.sermon || ''), scripture: '', theme: '', keywords: '', notes: '', suggestedSongs: '' };
          this.orderRows = [];
          this.showOrder = false;
          this.activeContentTab = 'scripture';
          this.resetTeamAssignments();
          this.resetRecommendations();
          notify('Service deleted.', 'success');
        } catch (e) {
          console.error(e);
          notify('Failed to delete service', 'error');
        }
      },

      async submit() {
        try {
          const isEdit = !!this.selectedServiceId;
          const payload = { ...this.form, scriptureText: this.scriptureText };
          if (isEdit) payload.id = this.selectedServiceId;
          const res = await callRpc(isEdit ? 'saveService' : 'addService', payload);
          const newId = (res && res.id) ? res.id : '';
          notify(isEdit ? 'Service saved.' : 'Service added.', 'success');
          this.loadingServices = true;
          try {
            const s = await callRpc('listServices', null);
            this.existingServices = Array.isArray(s?.items) ? s.items : this.existingServices;
          } catch (_) { /* ignore */ } finally {
            this.loadingServices = false;
          }
          if (newId) this.selectedServiceId = newId;
          this.loadTeamAssignments(this.selectedServiceId || newId || '');
          this.detailsDirty = false;
          this.detailsError = '';
          if (!this.orderRows || this.orderRows.length === 0) {
            this.orderRows = this.defaultOrderFor(this.form.type);
            this.ensureOrderOptionsFromRows();
            this.showOrder = true;
            // Persist initial default order to ServiceItems immediately
            this.queueSaveOrder(true);
          } else {
            try {
              const sid = this.selectedServiceId || newId;
              if (sid) await callRpc('saveOrder', { serviceId: sid, items: this.serializedOrder(), serviceDate: this.form?.date || '' });
            } catch (e2) { console.error(e2); notify('Saved service, but failed to save order.', 'error'); }
          }
          // stay on current tab (default scripture) after save
        } catch (e) {
          console.error(e);
          const msg = (e && e.message) ? e.message : 'Failed to save service';
          notify(msg, 'error');
        }
      },

      applyServiceDetails(svc, opts = {}) {
        if (!svc) return;
        const { force = false, focus = false, resetDirty = false } = opts || {};
        if (!force && this.detailsDirty) return;
        const defaults = (window.APP_CTX && window.APP_CTX.defaults) || {};
        const fallbackTime = defaults.time || '10:00 AM';
        const fallbackType = defaults.serviceType || 'Worship';
        const fallbackLeader = defaults.leader || 'Darden';
        const fallbackPreacher = defaults.preacher || defaults.sermon || 'Tom';
        this.form.id = svc.id || '';
        this.form.date = svc.date || this.nextSundayISO();
        this.form.time = svc.time || fallbackTime;
        this.form.type = svc.type || fallbackType;
        this.form.leader = svc.leader || fallbackLeader;
        this.form.preacher = svc.preacher || fallbackPreacher;
        this.form.scripture = svc.scripture || '';
        this.scriptureText = svc.scriptureText || '';
        this.form.theme = svc.theme || '';
        this.form.keywords = svc.keywords || '';
        this.form.notes = svc.notes || '';
        this.form.suggestedSongs = svc.suggestedSongs || '';
        this.syncRecommendationsFromStored();
        this.leaderSelect = this.leaderChoices.includes(this.form.leader) ? this.form.leader : '__custom';
        this.preacherSelect = this.preacherChoices.includes(this.form.preacher) ? this.form.preacher : '__custom';
        if (resetDirty) this.detailsDirty = false;
        this.$nextTick(() => {
          try {
            if (focus && this.$refs.dateInput) this.$refs.dateInput.focus();
          } catch (_) { }
          if (this.$refs.leaderSel) this.$refs.leaderSel.value = this.leaderSelect;
          if (this.$refs.preacherSel) this.$refs.preacherSel.value = this.preacherSelect;
        });
      },

      loadSelected() {
        try {
          if (this.saveDetailsTimer) {
            clearTimeout(this.saveDetailsTimer);
            this.saveDetailsTimer = null;
          }
        } catch (_) { }
        this.detailsDirty = false;
        this.detailsError = '';
        this.savingDetails = false;
        const svc = this.existingServices.find(s => s.id === this.selectedServiceId);
        if (!svc) return notify('Select a service first', 'info');
        this.resetRecommendations();
        this.applyServiceDetails(svc, { force: true, focus: true, resetDirty: true });
        this.loadingOrder = true;
        (async () => {
          try {
            const r = await callRpc('getOrder', this.selectedServiceId);
            this.orderRows = Array.isArray(r?.items) && r.items.length ? r.items : this.defaultOrderFor(this.form.type);
          } catch (_) {
            this.orderRows = this.defaultOrderFor(this.form.type);
          }
          this.ensureOrderOptionsFromRows();
          this.showOrder = true;
        })().finally(() => { this.loadingOrder = false; });
        try { localStorage.setItem('wp.selectedServiceId', this.selectedServiceId || ''); } catch (_) { }
        this.showDetails = true;
        this.activeContentTab = 'scripture';
        this.loadTeamAssignments(this.selectedServiceId);
      },

      resetTeamAssignments() {
        this.teamAssignments = [];
        this.teamAssignmentsError = '';
        this.teamAssignmentsLoading = false;
      },

      resetRecommendations() {
        this.recommendedSongs = [];
        this.recommendedSongsError = '';
        this.recommendedSongsLoading = false;
        this.recommendedSongIndex = -1;
        this.form.suggestedSongs = '';
        this.applySongsBrowserAiFilter();
      },

      syncRecommendationsFromStored() {
        try {
          const raw = String(this.form?.suggestedSongs || '').trim();
          if (!raw) {
            this.recommendedSongs = [];
            this.recommendedSongIndex = -1;
            this.recommendedSongsError = '';
            this.applySongsBrowserAiFilter();
            return;
          }
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            this.recommendedSongs = parsed.map((rec) => ({
              name: String(rec?.name || '').trim(),
              reason: String(rec?.reason || '').trim(),
              lyrics: String(rec?.lyrics || rec?.lyricSnippet || '').trim()
            })).filter(rec => rec.name || rec.reason || rec.lyrics);
            this.recommendedSongIndex = this.recommendedSongs.length ? 0 : -1;
            this.recommendedSongsError = '';
            this.applySongsBrowserAiFilter();
            return;
          }
        } catch (_) { /* ignore */ }
        this.recommendedSongs = [];
        this.recommendedSongIndex = -1;
        this.recommendedSongsError = '';
        this.applySongsBrowserAiFilter();
      },

      storeRecommendedSongsForService() {
        try {
          const payload = (Array.isArray(this.recommendedSongs) ? this.recommendedSongs : [])
            .map(rec => ({
              name: String(rec?.name || '').trim(),
              reason: String(rec?.reason || '').trim(),
              lyrics: String(rec?.lyrics || '').trim()
            }))
            .filter(rec => rec.name || rec.reason || rec.lyrics);
          const serialized = payload.length ? JSON.stringify(payload) : '';
          const changed = this.form.suggestedSongs !== serialized;
          this.form.suggestedSongs = serialized;
          return changed;
        } catch (_) {
          return false;
        }
      },

      activeRecommendedSong() {
        if (!Array.isArray(this.recommendedSongs) || !this.recommendedSongs.length) return null;
        if (this.recommendedSongIndex < 0 || this.recommendedSongIndex >= this.recommendedSongs.length) return this.recommendedSongs[0];
        return this.recommendedSongs[this.recommendedSongIndex];
      },

      async copyRecommendedLyrics() {
        try {
          const song = this.activeRecommendedSong();
          if (!song || !song.lyrics) return;
          await navigator.clipboard.writeText(song.lyrics);
          notify('Lyrics copied to clipboard.', 'success', 2000);
        } catch (_) {
          notify('Unable to copy lyrics.', 'error', 2000);
        }
      },

      recommendedSongPreview() {
        const song = this.activeRecommendedSong();
        if (!song) {
          return { hasSong: false };
        }
        return {
          hasSong: true,
          songName: song.name || '(Untitled)',
          reason: song.reason || '',
          keywords: this.form?.keywords || '',
          lyrics: song.lyrics || '',
          onCopy: () => this.copyRecommendedLyrics()
        };
      },

      recommendedSongTitles() {
        return (Array.isArray(this.recommendedSongs) ? this.recommendedSongs : [])
          .map((rec) => {
            const title = String(rec?.name || '').trim();
            if (!title) return null;
            return {
              title,
              reason: String(rec?.reason || '').trim()
            };
          })
          .filter(Boolean);
      },

      applySongsBrowserAiFilter() {
        const titles = this.recommendedSongTitles();
        const applyTo = (cmp) => {
          if (cmp && typeof cmp.setAiSongTitles === 'function') {
            cmp.setAiSongTitles(titles);
          }
        };
        if (this.embeddedSongsInstance) {
          applyTo(this.embeddedSongsInstance);
          return;
        }
        this.$nextTick(() => {
          try {
            const cmp = this.$refs?.embeddedSongsApp?.__x?.$data;
            applyTo(cmp);
          } catch (_) { /* ignore */ }
        });
      },

      async loadTeamAssignments(serviceId) {
        if (!this.teamAssignmentsSupported) return;
        const targetId = String(serviceId || '').trim();
        if (!targetId) {
          this.resetTeamAssignments();
          return;
        }
        this.teamAssignmentsLoading = true;
        this.teamAssignmentsError = '';
        try {
          const res = await callRpc('getServiceTeamAssignments', { serviceId: targetId });
          const list = Array.isArray(res?.teams) ? res.teams : [];
          this.teamAssignments = list.map(team => ({
            teamType: String(team?.teamType || 'Team'),
            weeklyTeamName: String(team?.weeklyTeamName || ''),
            roles: Array.isArray(team?.roles) ? team.roles.map(role => ({
              roleName: String(role?.roleName || role?.roleType || 'Role'),
              roleType: String(role?.roleType || ''),
              memberName: String(role?.memberName || ''),
              memberEmail: String(role?.memberEmail || ''),
              status: String(role?.status || ''),
              notes: String(role?.notes || '')
            })) : []
          }));
        } catch (err) {
          const message = (err && err.message) ? err.message : 'Failed to load team assignments.';
          if (/Unknown RPC method/i.test(message)) {
            this.teamAssignmentsSupported = false;
            this.teamAssignmentsUnsupportedReason = 'Team assignments require the latest server deployment. Push the updated Apps Script to enable this tab.';
            this.resetTeamAssignments();
            console.warn(message);
          } else {
            console.error(err);
            this.teamAssignmentsError = message;
          }
        } finally {
          this.teamAssignmentsLoading = false;
        }
      },

      chapterCountFor(bookName) {
        const e = this.books.find(b => b[0] === bookName);
        return e ? e[1] : 50;
      },

      scriptureRef() {
        const b = this.scripture.book;
        const c = this.scripture.chapter;
        const s = String(this.scripture.start || '').trim();
        const e = String(this.scripture.end || '').trim();
        if (!s && !e) return `${b} ${c}`;
        if (s && !e) return `${b} ${c}:${s}`;
        return `${b} ${c}:${s}-${e}`;
      },

      ensureDefaults() {
        const d = (window.APP_CTX && window.APP_CTX.defaults) || {};
        const defLeader = d.leader || 'Darden';
        const defPreacher = d.preacher || d.sermon || 'Tom';
        if (!this.leaderChoices.includes(defLeader)) this.leaderChoices = [defLeader, ...this.leaderChoices];
        if (!this.preacherChoices.includes(defPreacher)) this.preacherChoices = [defPreacher, ...this.preacherChoices];
        this.leaderSelect = defLeader;
        this.preacherSelect = defPreacher;
        this.form.leader = defLeader;
        this.form.preacher = defPreacher;
        this.$nextTick(() => {
          if (this.$refs.leaderSel) this.$refs.leaderSel.value = defLeader;
          if (this.$refs.preacherSel) this.$refs.preacherSel.value = defPreacher;
        });
      },

      async fetchScripture() {
        try {
          const ref = String(this.form.scripture || '').trim();
          if (!ref) { this.scriptureText = ''; return; }
          const prev = this.scriptureText;
          const r = await callRpc('esvPassage', { reference: ref });
          if (r && r.error) {
            notify(String(r.error), 'error', 3200);
            this.scriptureText = prev; // preserve existing text
            return;
          }
          const txt = (r && r.text) ? String(r.text) : '';
          if (!txt.trim()) {
            notify('No passage found - check the reference.', 'error', 2600);
            this.scriptureText = prev;
          } else {
            this.scriptureText = txt;
            // Auto-generate keywords from scripture text
            try { this.form.keywords = this.extractKeywords(txt); } catch (_) { }
            this.queueSaveDetails(true);
          }
        } catch (e) {
          console.error(e);
          const msg = (e && e.message) ? e.message : 'Failed to fetch scripture text';
          notify(msg, 'error', 3200);
        }
      },

      async updateNotesWithThemes(passageText, reference) {
        const text = String(passageText || '').trim();
        if (!text) return;
        const ref = String(reference || '').trim();
        this.recommendedSongsLoading = true;
        this.recommendedSongsError = '';
        let needsSave = false;
        try {
          const res = await callRpc('summarizeScriptureThemes', { text, reference: ref, leader: this.form.leader, songLimit: 10 });
          const summary = String(res?.summary || '').trim();
          if (summary) {
            if (this.form.notes !== summary) {
              this.form.notes = summary;
              needsSave = true;
            }
          }
          if (Array.isArray(res?.recommendedSongs)) {
            this.recommendedSongs = res.recommendedSongs.map((rec) => ({
              name: String(rec?.name || '').trim(),
              lyrics: String(rec?.lyrics || rec?.lyricExcerpt || '').trim(),
              reason: String(rec?.reason || '').trim()
            })).filter(rec => rec.name || rec.lyrics || rec.reason);
            this.recommendedSongIndex = this.recommendedSongs.length ? 0 : -1;
            if (this.storeRecommendedSongsForService()) needsSave = true;
          } else {
            this.recommendedSongs = [];
            this.recommendedSongIndex = -1;
            if (this.storeRecommendedSongsForService()) needsSave = true;
          }
          if (res?.summaryError) {
            console.warn('Theme summary warning:', res.summaryError);
          } else if (res?.error) {
            console.warn('Theme summary warning:', res.error);
          }
          if (res?.recommendedSongsError) {
            this.recommendedSongsError = res.recommendedSongsError;
            console.warn('Song recommendation warning:', res.recommendedSongsError);
          } else {
            this.recommendedSongsError = '';
          }
        } catch (err) {
          const message = (err && err.message) ? err.message : '';
          if (/Unknown RPC method/i.test(message)) {
            console.info('Theme summaries not yet supported on this deployment.');
          } else {
            console.error('Failed to summarize scripture themes', err);
            this.recommendedSongsError = 'Unable to fetch song recommendations.';
          }
        } finally {
          this.recommendedSongsLoading = false;
        }
        if (needsSave) this.queueSaveDetails(true);
        this.applySongsBrowserAiFilter();
      },

      async fetchSongSuggestions() {
        const text = String(this.scriptureText || '').trim();
        const ref = String(this.form?.scripture || '').trim();
        if (!text || !ref) {
          notify('Enter a scripture reference and fetch the text first.', 'info');
          return;
        }
        await this.updateNotesWithThemes(text, ref);
      },

      // Create a comma-separated keyword list from passage text
      extractKeywords(text) {
        const s = String(text || '').toLowerCase();
        if (!s) return '';
        // Tokenize words
        const tokens = s.replace(/[^a-z\s']/g, ' ').split(/\s+/).map(t => t.replace(/^'+|'+$/g, '')).filter(Boolean);
        if (!tokens.length) return '';
        // Stop words (expanded with pronouns/prepositions like him, whoever, into)
        const stop = new Set([
          'the', 'and', 'of', 'to', 'in', 'that', 'it', 'is', 'for', 'on', 'with', 'as', 'at', 'by', 'be', 'he', 'she', 'they', 'we', 'you', 'i', 'a', 'an', 'from', 'this', 'these', 'those', 'are', 'was', 'were', 'his', 'her', 'their', 'our', 'your', 'but', 'not', 'so', 'or', 'if', 'then', 'there', 'here', 'who', 'whom', 'which', 'what', 'when', 'where', 'why', 'how', 'have', 'has', 'had', 'do', 'did', 'does', 'will', 'would', 'shall', 'should', 'can', 'could', 'may', 'might', 'let', 'us',
          'him', 'them', 'me', 'my', 'mine', 'yours', 'ours', 'hers', 'theirs', 'whoever', 'whosoever', 'whomever', 'whose', 'into', 'unto', 'onto', 'upon', 'within', 'without', 'among', 'between', 'before', 'after', 'above', 'below', 'over', 'under', 'again', 'also', 'all', 'any', 'each', 'every', 'some', 'no', 'nor', 'one', 'thing', 'things', 'because'
        ]);
        // Lemmatization + grouping without truncation
        const lemma = (w) => {
          if (!w) return '';
          // groups
          if (/^bright(?:ness)?$/.test(w) || /^shine(?:s|r|rs|d|ing)?$/.test(w)) return 'light';
          if (/^light(?:s|er|est|ness)?$/.test(w)) return 'light';
          if (/^dark(?:ness|er|est|s)?$/.test(w)) return 'darkness';
          if (/^judg(?:e|es|ed|ing|ment|ments)$/.test(w) || /^condemn(?:ed|s|ing|ation|ations)?$/.test(w)) return 'judgment';
          if (/^believ(?:e|es|ed|ing|er|ers)?$/.test(w)) return 'believe';
          if (/^baptiz(?:e|es|ed|ing)?$/.test(w) || /^baptism(?:s)?$/.test(w) || /^baptist(?:s)?$/.test(w)) return 'baptism';
          if (/^come(?:s|r|rs|ing)?$/.test(w) || w === 'came') return 'come';
          // Gentle plural handling
          if (w.length > 4 && /s$/.test(w)) return w.replace(/s$/, '');
          return w;
        };
        const counts = new Map();
        for (const t of tokens) {
          if (stop.has(t) || t.length < 3) continue;
          const k = lemma(t);
          if (!k || stop.has(k) || k.length < 3) continue;
          counts.set(k, (counts.get(k) || 0) + 1);
        }
        const top = Array.from(counts.entries()).sort((a, b) => b[1] - a[1]).slice(0, 12).map(([k]) => k);
        // Pretty case
        const pretty = (w) => w.replace(/^\w/, c => c.toUpperCase());
        return top.map(pretty).join(', ');
      },

      formattedDateTime() {
        const dateStr = String(this.form?.date || '').trim();
        const timeStr = String(this.form?.time || '').trim();
        const idStr = String(this.form?.id || '').trim();
        let prettyDate = '';
        let prettyTime = '';

        if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
          try {
            const [y, m, d] = dateStr.split('-').map(Number);
            prettyDate = new Intl.DateTimeFormat('en-US', {
              month: 'long',
              day: 'numeric',
              year: 'numeric'
            }).format(new Date(y, m - 1, d));
          } catch (_) {
            prettyDate = dateStr;
          }
        } else {
          prettyDate = dateStr;
        }

        if (timeStr) {
          const match = timeStr.match(/^(\d{1,2})(?::(\d{2}))?\s*(AM|PM)$/i);
          if (match) {
            const minutes = match[2] || '00';
            const meridiem = match[3].toUpperCase();
            const hour = parseInt(match[1], 10);
            prettyTime = minutes !== '00' ? `${hour}:${minutes} ${meridiem}` : `${hour} ${meridiem}`;
          } else {
            prettyTime = timeStr;
          }
        }

        const idTime = (() => {
          if (!idStr) return '';
          const m = idStr.match(/_(\d{1,2})(?::?(\d{2}))?(am|pm)\b/i);
          if (!m) return '';
          const hour = parseInt(m[1], 10);
          const minutes = m[2] || '';
          const meridiem = m[3].toUpperCase();
          return minutes ? `${hour}:${minutes} ${meridiem}` : `${hour} ${meridiem}`;
        })();

        const normalize = (s) => String(s || '').replace(/[^0-9a-z]/gi, '').toLowerCase();
        if (!prettyTime && idTime) {
          prettyTime = idTime;
        } else if (prettyTime && idTime && normalize(prettyTime) !== normalize(idTime)) {
          prettyTime = idTime;
        }

        return { date: prettyDate, time: prettyTime };
      },

      formattedDateTimeHtml() {
        const { date, time } = this.formattedDateTime();
        return [date, time].filter(Boolean).join('<br>');
      },

      formattedDateTimePlain() {
        const { date, time } = this.formattedDateTime();
        return [date, time].filter(Boolean).join(' ');
      },


      // Order helpers
      defaultOrderFor(serviceType) {
        const t = String(serviceType || '').toLowerCase();
        const tmpl = (window.APP_CTX && window.APP_CTX.orderTemplates) || {};
        const src = t.includes('communion') ? tmpl.communion : t.includes('offering') ? tmpl.offering : (tmpl.offering || []);
        const arr = Array.isArray(src) ? src : [];
        const leaderName = this.form?.leader || '';
        const preacherName = this.form?.preacher || '';
        const sub = (s) => {
          const v = String(s || '');
          if (!v) return '';
          return v.replace('{leader}', leaderName).replace('{preacher}', preacherName);
        };
        return arr.map((it, idx) => ({
          order: idx + 1,
          itemType: String(it.itemType || ''),
          detail: it.detail || '',
          leader: sub(it.leader),
          notes: it.notes || ''
        }));
      },
      addOrderRow() {
        const n = this.orderRows.length + 1;
        this.orderRows.push({ order: n, itemType: '', detail: '', leader: '', notes: '' });
        this.queueSaveOrder(true);
      },
      removeOrderRow(i) {
        this.orderRows.splice(i, 1);
        this.orderRows.forEach((r, idx) => (r.order = idx + 1));
        this.queueSaveOrder(true);
      },
      moveOrderRow(i, dir) {
        const j = i + dir;
        if (j < 0 || j >= this.orderRows.length) return;
        const tmp = this.orderRows[i];
        this.orderRows[i] = this.orderRows[j];
        this.orderRows[j] = tmp;
        this.orderRows.forEach((r, idx) => (r.order = idx + 1));
        this.queueSaveOrder(true);
      },
      serializedOrder() {
        return this.orderRows.map((r, idx) => ({ order: idx + 1, itemType: r.itemType || '', detail: r.detail || '', scriptureText: r.scriptureText || '', leader: r.leader || '', notes: r.notes || '' }));
      },

      slotFor(i) {
        const t = String(this.orderRows[i]?.itemType || '').toLowerCase();
        return t;
      },
      async suggestForRow(i) {
        if (this.loadingSuggestion) return;
        this.suggestTargetIndex = i;
        const t = String(this.orderRows[i]?.itemType || '').toLowerCase();
        const isScripture = t.includes('scripture') || t.includes('call to worship');
        if (!isScripture) {
          this.suggestOpenIndex = i;
          this.updateSuggestDefaults(i);
          this.showSuggestModal = true;
          const existing = String(this.orderRows[i]?.detail || '').trim();
          if (existing) {
            this.$nextTick(() => this.focusSongInSuggestModal(existing));
          }
          return;
        }
        this.loadingSuggestion = true;
        try {
          // Scripture suggestions based on adjacent songs or service context
          const neighbors = this.adjacentSongs(i);
          const names = neighbors.filter(Boolean);
          const refs = new Set();
          let songPayload = [];
          if (names.length) {
            const songs = await this.getSongsCache();
            const findRow = (name) => this.findSongRowByName(name, songs);
            for (const n of names) {
              const row = findRow(n);
              const scr = row ? this.field(row, ['scriptures', 'scripture refs', 'scripture']) : '';
              scr.split(/[,;|\n]+/).map(s => s.trim()).filter(Boolean).forEach(v => refs.add(v));
            }
            try {
              const fetch = await callRpc('getSongFields', { names, fields: ['Lyrics', 'Themes'] });
              const items = Array.isArray(fetch?.items) ? fetch.items : [];
              songPayload = names.map(n => {
                const it = items.find(x => String(x?.name || '').toLowerCase() === String(n).toLowerCase()) || items.find(x => String(x?.name || '').toLowerCase().includes(String(n).toLowerCase())) || null;
                const lyrics = it && it.fields ? String(it.fields['Lyrics'] || '') : '';
                return { name: n, lyrics };
              });
              try {
                const withLyrics = songPayload.filter(s => (s.lyrics || '').trim()).length;
                notify(`AI payload songs: ${songPayload.length}, with lyrics: ${withLyrics}`, 'info', 1200);
              } catch (_) { }
            } catch (err) {
              console.error('Failed to pull song lyrics for scripture ideas', err);
            }
          } else {
            try { notify('Using service theme and keywords for scripture ideas.', 'info', 1600); } catch (_) { }
          }

          if (songPayload.length) {
            try {
              const lyricRefs = await this.requestScriptureIdeas({
                songs: songPayload,
                theme: this.form.theme,
                keywords: this.form.keywords,
                primaryScripture: this.form.scripture,
                reason: 'lyrics',
                limit: 12
              });
              lyricRefs.forEach(v => refs.add(String(v)));
              try { notify(`AI refs from lyrics: ${lyricRefs.length}`, 'info', 1400); } catch (_) { }
            } catch (err) {
              console.error('AI lyric scripture fetch failed', err);
            }
          }

          if (!refs.size) {
            try {
              const fallbackRefs = await this.requestScriptureIdeas({
                songs: [],
                theme: this.form.theme,
                keywords: this.form.keywords,
                primaryScripture: this.form.scripture,
                reason: songPayload.length ? 'lyrics-fallback' : 'context',
                limit: 12
              });
              fallbackRefs.forEach(v => refs.add(String(v)));
              if (fallbackRefs.length) {
                try { notify(`AI refs from service context: ${fallbackRefs.length}`, 'info', 1600); } catch (_) { }
              }
            } catch (err) {
              console.error('AI fallback scripture fetch failed', err);
            }
          }

          const seedRefs = Array.from(refs.values());
          const additions = this.mergeScriptureSuggestions(seedRefs, { reset: true });
          this.scriptureSuggestIndex = i;
          this.prepareScriptureSearchDefaults();
          let defaultRef = additions[0] || String(this.orderRows[i]?.detail || '').trim() || this.mainScriptureRef();
          if (!defaultRef && this.scriptureSuggestions.length) defaultRef = this.scriptureSuggestions[0];
          this.openScriptureModal({ defaultRef, autoFetch: !!defaultRef });
          if (!this.scriptureSuggestions.length && !defaultRef) {
            this.scriptureSearchError = 'No ideas yet. Adjust theme/keywords and try again.';
          }
        } catch (e) {
          console.error(e);
          notify('Failed to build suggestions', 'error');
        } finally {
          this.loadingSuggestion = false;
        }
      },

      adjacentSongs(i) {
        const isSong = (t) => /song\b|closing song|opening song|communion song|offering song/i.test(String(t || ''));
        let prev = '', next = '';
        for (let j = i - 1; j >= 0; j--) { const r = this.orderRows[j]; if (r && isSong(r.itemType) && String(r.detail || '').trim()) { prev = String(r.detail); break; } }
        for (let j = i + 1; j < this.orderRows.length; j++) { const r = this.orderRows[j]; if (r && isSong(r.itemType) && String(r.detail || '').trim()) { next = String(r.detail); break; } }
        return [prev, next];
      },

      async getSongsCache() {
        if (Array.isArray(this._songsCache)) return this._songsCache;
        try { const r = await callRpc('getSongsForView', null); this._songsCache = Array.isArray(r) ? r : []; } catch (_) { this._songsCache = []; }
        return this._songsCache;
      },

      applyScriptureSuggestion(i, ref) {
        try { this.orderRows[i].detail = String(ref || ''); this.scriptureSuggestIndex = -1; this.scriptureSuggestions = []; } catch (_) { }
        this.queueSaveOrder(true);
      },

      prepareScriptureSearchDefaults() {
        this.scriptureSearchTheme = String(this.form.theme || '');
        this.scriptureSearchKeywords = String(this.form.keywords || '');
        this.scriptureSearchPrimary = this.mainScriptureRef();
        this.scriptureSearchError = '';
      },

      async requestScriptureIdeas({ songs = [], theme = '', keywords = '', primaryScripture = '', reason = 'manual', limit = 12 } = {}) {
        const payload = {
          songs: Array.isArray(songs) ? songs : [],
          theme: String(theme || ''),
          keywords: String(keywords || ''),
          primaryScripture: String(primaryScripture || ''),
          k: Number.isFinite(limit) ? limit : 12,
          reason
        };
        const res = await callRpc('aiScripturesForLyrics', payload);
        const refs = Array.isArray(res?.refs) ? res.refs : [];
        return refs.map(r => String(r || '').trim()).filter(Boolean);
      },

      async refreshScriptureIdeas(reason = 'manual') {
        if (this.scriptureSearchPending) return;
        this.scriptureSearchError = '';
        this.scriptureSearchPending = true;
        try {
          const refs = await this.requestScriptureIdeas({
            songs: [],
            theme: this.scriptureSearchTheme || this.form.theme,
            keywords: this.scriptureSearchKeywords || this.form.keywords,
            primaryScripture: this.scriptureSearchPrimary || this.form.scripture,
            reason,
            limit: 16
          });
          const additions = this.mergeScriptureSuggestions(refs, { reset: false });
          if (additions.length) {
            this.selectedScriptureRef = additions[0];
            this.selectedScriptureText = '';
            this.selectedScriptureHtml = '';
            this.$nextTick(() => this.fetchPassage(this.selectedScriptureRef));
            this.isScriptureEditing = false;
          } else if (!this.selectedScriptureRef) {
            const fallbackRef = this.scriptureSuggestions[0] || this.mainScriptureRef();
            if (fallbackRef) {
              this.selectedScriptureRef = fallbackRef;
              this.$nextTick(() => this.fetchPassage(this.selectedScriptureRef));
              this.isScriptureEditing = false;
            } else {
              this.selectedScriptureHtml = '';
              this.isScriptureEditing = true;
            }
          }
          if (!additions.length) {
            if (!this.scriptureSuggestions.length) {
              this.scriptureSearchError = 'No passages returned. Try adjusting keywords or theme.';
            } else {
              this.scriptureSearchError = 'No new passages returned; existing references kept.';
            }
          }
        } catch (err) {
          const msg = (err && err.message) ? err.message : 'Failed to fetch scripture ideas';
          this.scriptureSearchError = msg;
          try { if (typeof notify === 'function') notify(msg, 'error'); } catch (_) { }
        } finally {
          this.scriptureSearchPending = false;
        }
      },

      openScriptureModal({ defaultRef = '', autoFetch = true } = {}) {
        try {
          this.selectedScriptureRef = String(defaultRef || '');
          const cached = this.selectedScriptureRef && this._passageCache ? this._passageCache[this.selectedScriptureRef] : null;
          if (cached) {
            this.selectedScriptureText = String(cached.text || '');
            this.selectedScriptureHtml = String(cached.html || '');
          } else {
            this.selectedScriptureText = '';
            this.selectedScriptureHtml = '';
          }
          this.showScriptureModal = true;
          this.isScriptureEditing = !this.selectedScriptureHtml && !!this.selectedScriptureText;
          if (!this.selectedScriptureRef) this.isScriptureEditing = true;
          if (autoFetch && this.selectedScriptureRef) {
            this.$nextTick(() => { this.fetchPassage(this.selectedScriptureRef); });
          }
        } catch (_) { this.showScriptureModal = true; }
      },

      async fetchPassage(ref) {
        const key = String(ref || '').trim();
        const wasEditing = this.isScriptureEditing;
        if (!key) {
          this.selectedScriptureText = '';
          this.selectedScriptureHtml = '';
          this.isScriptureEditing = true;
          return;
        }
        const cached = this._passageCache && this._passageCache[key];
        if (cached) {
          this.selectedScriptureText = String(cached.text || '');
          this.selectedScriptureHtml = String(cached.html || '');
          this.isScriptureEditing = wasEditing;
          return;
        }
        try {
          const r = await callRpc('esvPassage', { reference: key });
          const txt = (r && r.text) ? String(r.text) : '';
          const html = (r && r.html) ? String(r.html) : '';
          this.selectedScriptureText = txt;
          this.selectedScriptureHtml = html;
          try { this._passageCache[key] = { text: txt, html }; } catch (_) { }
          this.isScriptureEditing = wasEditing;
        } catch (err) {
          console.error('Failed to fetch passage', err);
          this.selectedScriptureText = '';
          this.selectedScriptureHtml = '';
          this.isScriptureEditing = true;
        }
      },

      chooseScripture() {
        const i = this.scriptureSuggestIndex;
        if (i < 0) { this.showScriptureModal = false; return; }
        const ref = String(this.selectedScriptureRef || '');
        if (ref) {
          this.applyScriptureSuggestion(i, ref);
          try { this.orderRows[i].scriptureText = String(this.selectedScriptureText || ''); } catch (_) { }
          this.queueSaveOrder(true);
        }
        this.showScriptureModal = false;
      },

      toggleScriptureEditing() {
        this.isScriptureEditing = !this.isScriptureEditing;
        if (this.isScriptureEditing) {
          this.$nextTick(() => {
            try {
              const el = this.$refs?.scriptureEditor;
              if (el && typeof el.focus === 'function') el.focus();
            } catch (_) { }
          });
        }
      },

      refChanged() {
        try { if (this._refTimer) clearTimeout(this._refTimer); } catch (_) { }
        this.selectedScriptureHtml = '';
        if (!this.isScriptureEditing) this.selectedScriptureText = '';
        this._refTimer = setTimeout(() => this.fetchPassage(this.selectedScriptureRef), 500);
      },

      customScriptureEdited() {
        try {
          if (this.selectedScriptureRef) {
            this._passageCache[this.selectedScriptureRef] = { text: this.selectedScriptureText || '', html: '' };
          }
        } catch (_) { }
        this.selectedScriptureHtml = '';
        this.isScriptureEditing = true;
      },

      mainScriptureRef() {
        return String(this.form?.scripture || '').trim();
      },

      normalizeRef(ref) {
        return String(ref || '').trim().replace(/\s+/g, ' ').toLowerCase();
      },

      mergeScriptureSuggestions(newRefs, { reset = false } = {}) {
        const base = reset ? [] : (Array.isArray(this.scriptureSuggestions) ? [...this.scriptureSuggestions] : []);
        const seen = new Set(base.map(r => this.normalizeRef(r)));
        const mainNorm = this.normalizeRef(this.mainScriptureRef());
        const added = [];
        for (const ref of Array.isArray(newRefs) ? newRefs : []) {
          const norm = this.normalizeRef(ref);
          if (!norm) continue;
          if (norm === mainNorm) continue;
          if (seen.has(norm)) continue;
          seen.add(norm);
          const clean = String(ref).trim();
          base.push(clean);
          added.push(clean);
        }
        this.scriptureSuggestions = base.slice(0, 40);
        return added;
      },

      // Helper to read a row field with flexible header names
      field(row, candidates) {
        if (!row) return '';
        const keys = Object.keys(row);
        const L = keys.map(k => k.toLowerCase());
        for (const cand of candidates) {
          const i = L.indexOf(String(cand).toLowerCase());
          if (i >= 0) return String(row[keys[i]] ?? '');
        }
        // fallback: partial contains match
        for (const cand of candidates) {
          const ci = L.findIndex(k => k.includes(String(cand).toLowerCase()));
          if (ci >= 0) return String(row[keys[ci]] ?? '');
        }
        return '';
      },

      normalizeTitle(s) {
        let t = String(s || '').toLowerCase();
        t = t.replace(/\([^)]*\)|\[[^\]]*\]/g, ' '); // remove () or [] content
        t = t.replace(/\+sp|\+es/g, ' ');              // drop language tags like (+Sp)
        t = t.replace(/[^a-z0-9\s]/g, ' ');
        t = t.replace(/\s+/g, ' ').trim();
        return t;
      },

      findSongRowByName(name, songs) {
        const q = this.normalizeTitle(name);
        if (!q) return null;
        let best = null; let bestScore = 0;
        for (const r of (songs || [])) {
          const t = this.normalizeTitle((r && (r.Song || r['song'] || r['Title'])) || '');
          if (!t) continue;
          if (t === q) return r; // exact
          if (t.includes(q) || q.includes(t)) {
            const sc = Math.min(t.length, q.length) / Math.max(t.length, q.length);
            if (sc > bestScore) { best = r; bestScore = sc; }
            continue;
          }
          const A = new Set(t.split(' '));
          const B = new Set(q.split(' '));
          let inter = 0; for (const x of A) if (B.has(x)) inter++;
          const union = A.size + B.size - inter;
          const j = union ? inter / union : 0;
          if (j > bestScore) { best = r; bestScore = j; }
        }
        return best;
      },

      normalizeTitle(s) {
        return String(s || '')
          .toLowerCase()
          .replace(/[^a-z0-9\s]+/g, ' ')
          .replace(/\s+/g, ' ')
          .trim();
      },

      findSongRowByName(name, songs) {
        const q = this.normalizeTitle(name);
        if (!q) return null;
        let best = null; let bestScore = 0;
        for (const r of (songs || [])) {
          const t = this.normalizeTitle((r && (r.Song || r['song'] || r['Title'])) || '');
          if (!t) continue;
          if (t === q) return r; // exact
          // two-way contains
          if (t.includes(q) || q.includes(t)) {
            const sc = Math.min(t.length, q.length) / Math.max(t.length, q.length);
            if (sc > bestScore) { best = r; bestScore = sc; }
            continue;
          }
          // token overlap
          const A = new Set(t.split(' '));
          const B = new Set(q.split(' '));
          let inter = 0; for (const x of A) if (B.has(x)) inter++;
          const union = A.size + B.size - inter;
          const j = union ? inter / union : 0;
          if (j > bestScore) { best = r; bestScore = j; }
        }
        return bestScore >= 0.45 ? best : best; // return best anyway for debugging
      },
      applySuggestion(i, s) {
        const chosen = s?.name || '';
        this.orderRows[i].detail = chosen;
        this.suggestOpenIndex = -1;
        this.suggestions = [];
        this.queueSaveOrder(true);
        this.bumpSongUsage(chosen, this.orderRows[i]?.itemType, this.orderRows[i]?.leader);
      },

      async bumpSongUsage(name, itemType, leaderName) {
        if (this.isGuest) return;
        try {
          const songName = String(name || '').trim();
          if (!songName) return;
          const date = String(this.form?.date || '').trim();
          const usage = this.usageFromItemType(itemType || '');
          const payload = { name: songName, date };
          if (usage) payload.usage = usage;
          const leaderValue = String(leaderName || this.form?.leader || '').trim();
          if (leaderValue) payload.leader = leaderValue;
          const res = await callRpc('updateSongUsage', payload);
          const target = this.normalizeTitle(songName);
          const applyPatch = (row) => {
            if (!row) return;
            const title = this.normalizeTitle((row && (row.Song || row['song'] || row['Title'])) || '');
            if (title === target) {
              if (res && res.lastUsed) row.Last_Used = res.lastUsed;
              if (res && typeof res.uses === 'number') row.Uses = res.uses;
              if (res && res.years) row.Years_Used = res.years;
              if (res && res.usage) row.Usage = res.usage;
              if (res && res.leader) row.Leader = res.leader;
            }
          };
          if (Array.isArray(window.__ROWS__)) {
            window.__ROWS__.forEach(applyPatch);
          }
          const store = this.suggestModalStore();
          if (store) {
            try {
              if (Array.isArray(store.rows)) store.rows.forEach(applyPatch);
              if (Array.isArray(store.filtered)) store.filtered.forEach(applyPatch);
              if (typeof store.render === 'function') store.render(false);
            } catch (_) { }
          }
        } catch (e) {
          console.error('Failed to update song usage', e);
        }
      },

      suggestModalStore() {
        try {
          const modal = this.$refs?.suggestApp;
          if (modal && modal.__x && modal.__x.$data) {
            return modal.__x.$data;
          }
        } catch (_) { }
        return null;
      },

      async focusSongInSuggestModal(name) {
        const title = String(name || '').trim();
        if (!title) return;
        const store = this.suggestModalStore();
        if (!store) return;
        if (typeof store.focusOnSong === 'function') {
          try {
            const focused = await store.focusOnSong.call(store, title, { clearFilters: true });
            if (focused) return;
          } catch (_) { }
        }
        const forceRender = () => {
          try {
            if (typeof store.render === 'function') {
              store.render.call(store, true);
            }
          } catch (_) { }
        };
        const relaxFilters = () => {
          let changed = false;
          const ensure = (key, value) => {
            if (store[key] !== value) {
              store[key] = value;
              changed = true;
            }
          };
          ensure('selectedSeason', '');
          ensure('selectedLeader', '');
          ensure('selectedUsage', '');
          ensure('spanishOnly', false);
          ensure('showArchived', true);
          return changed;
        };
        try {
          if (typeof store.ensureRowsLoaded === 'function') {
            await store.ensureRowsLoaded.call(store);
          }
        } catch (_) { }
        let match = null;
        try {
          if (typeof store.findSongByName === 'function') {
            match = store.findSongByName(title);
          }
        } catch (_) { }
        if (!match) {
          const rows = Array.isArray(store.rows) ? store.rows : [];
          match = this.findSongRowByName(title, rows);
        }
        if (match) {
          const qChanged = store.q !== title;
          const filtersChanged = relaxFilters();
          if (qChanged) {
            store.q = title;
          }
          if (qChanged || filtersChanged) {
            forceRender();
          } else {
            forceRender();
          }
          try {
            if (typeof store.select === 'function') {
              await store.select.call(store, match);
            } else {
              store.selected = match;
            }
          } catch (_) {
            store.selected = match;
          }
          return;
        }
        const qChanged = store.q !== title;
        const filtersChanged = relaxFilters();
        if (qChanged) store.q = title;
        if (qChanged || filtersChanged) {
          forceRender();
        } else {
          forceRender();
        }
      },

      isAdventChristmas(dateISO) {
        try {
          const s = String(dateISO || '').trim();
          if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return false;
          const [y, m, d] = s.split('-').map(Number);
          if (m === 12) return true;
          if (m === 11 && d >= 27) return true;
          if (m === 1 && d <= 6) return true;
          return false;
        } catch (_) {
          return false;
        }
      },

      usageFromItemType(label) {
        const s = String(label || '').toLowerCase();
        if (!s) return '';
        if (s.includes('call to worship') || s.includes('opening')) return 'Call to Worship';
        if (/\bsong\s*2\b/.test(s)) return 'Song2';
        if (/\bsong\s*3\b/.test(s)) return 'Song3';
        if (/\bsong\s*4\b/.test(s)) return 'Song4';
        if (s.includes('communion')) return 'Communion';
        if (s.includes('offering')) return 'Offering';
        if (s.includes('closing')) return 'Closing';
        return '';
      },

      ensureOrderOptionsFromRows() {
        try {
          const set = new Set(this.orderItemTypes);
          for (const r of this.orderRows) {
            const v = String(r?.itemType || '').trim();
            if (v && !set.has(v)) set.add(v);
          }
          this.orderItemTypes = Array.from(set);
        } catch (_) { }
      },

      serviceLabel(svc) {
        if (!svc) return '';
        const sourceDate = svc.date || this.parseDateFromServiceId(svc.id);
        const datePart = this.formatDateLabel(sourceDate);
        const idTime = this.parseTimeFromServiceId(svc.id);
        let timePart = idTime || this.formatTimeLabel(svc.time);
        if (!timePart) timePart = this.formatTimeLabel(idTime);
        const leader = String(svc.leader || '').trim();
        const leaderPart = leader ? ` (${leader})` : '';
        const dateTime = [datePart, timePart].filter(Boolean).join(' ').trim();
        if (!dateTime) {
          return String(svc.id || leader || 'Service');
        }
        return `${dateTime}${leaderPart}`;
      },

      formatDateLabel(value) {
        if (!value && value !== 0) return '';
        const dateObj = this.parseDateValue(value);
        if (dateObj) {
          const yy = String(dateObj.getFullYear()).slice(-2);
          const mm = String(dateObj.getMonth() + 1).padStart(2, '0');
          const dd = String(dateObj.getDate()).padStart(2, '0');
          return `${yy}-${mm}-${dd}`;
        }
        const raw = String(value || '').trim();
        if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) {
          return raw.slice(2);
        }
        return raw;
      },

      parseDateValue(value) {
        if (!value && value !== 0) return null;
        if (value instanceof Date && !isNaN(value)) return value;
        if (typeof value === 'number' && Number.isFinite(value)) {
          if (value > 1000000000) {
            const asDate = new Date(value);
            if (!isNaN(asDate)) return asDate;
          } else if (value > 0 && value < 60000) {
            const epoch = (value - 25569) * 86400 * 1000;
            const asDate = new Date(epoch);
            if (!isNaN(asDate)) return asDate;
          }
        }
        const raw = String(value || '').trim();
        if (!raw) return null;
        if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) {
          const [y, m, d] = raw.split('-').map(Number);
          return new Date(y, m - 1, d);
        }
        const parsed = Date.parse(raw);
        if (!Number.isNaN(parsed)) return new Date(parsed);
        return null;
      },

      formatTimeLabel(value) {
        if (!value && value !== 0) return '';
        if (value instanceof Date && !isNaN(value)) return this.formatTimeFromDate(value);
        if (typeof value === 'number' && Number.isFinite(value)) {
          if (value > 1000000000) {
            const asDate = new Date(value);
            if (!isNaN(asDate)) return this.formatTimeFromDate(asDate);
          } else if (value > 0 && value < 1) {
            const totalMinutes = Math.round(value * 24 * 60);
            const h = Math.floor(totalMinutes / 60);
            const m = totalMinutes % 60;
            return this.formatHourMinute(h, m);
          }
        }
        const raw = String(value || '').trim();
        if (!raw) return '';
        const ampm = raw.match(/^(\d{1,2})(?::(\d{2}))?\s*(AM|PM)$/i);
        if (ampm) {
          const hourNum = Number(ampm[1]);
          const mins = ampm[2] ? Number(ampm[2]) : 0;
          if (Number.isFinite(hourNum)) {
            const minsPart = mins ? `:${String(mins).padStart(2, '0')}` : '';
            return `${hourNum}${minsPart}${ampm[3].toLowerCase()}`;
          }
        }
        const parsed = Date.parse(raw);
        if (!Number.isNaN(parsed)) {
          return this.formatTimeFromDate(new Date(parsed));
        }
        const timeOnly = raw.match(/^(\d{1,2})(?::(\d{2}))(?::(\d{2}))?$/);
        if (timeOnly) {
          const hour = Number(timeOnly[1]);
          const mins = Number(timeOnly[2] || '0');
          if (Number.isFinite(hour) && hour >= 0 && hour < 24) {
            return this.formatHourMinute(hour, mins);
          }
        }
        return '';
      },

      formatTimeFromDate(dateObj) {
        if (!(dateObj instanceof Date) || isNaN(dateObj)) return '';
        const hours = dateObj.getHours();
        const mins = dateObj.getMinutes();
        return this.formatHourMinute(hours, mins);
      },

      formatHourMinute(hours24, mins) {
        if (!Number.isFinite(hours24)) return '';
        const suffix = hours24 >= 12 ? 'pm' : 'am';
        const hour12 = ((hours24 % 12) || 12);
        const minsPart = mins ? `:${String(mins).padStart(2, '0')}` : '';
        return `${hour12}${minsPart}${suffix}`;
      },

      parseDateFromServiceId(id) {
        const raw = String(id || '').trim();
        if (!raw) return '';
        const match = raw.match(/^(\d{4}-\d{2}-\d{2})/);
        return match ? match[1] : '';
      },

      parseTimeFromServiceId(id) {
        const raw = String(id || '').trim();
        if (!raw) return '';
        const match = raw.match(/_(\d{1,2}(?::\d{2})?(?:am|pm))/i);
        if (match && match[1]) {
          return match[1];
        }
        return '';
      },

      updateCachedService(id, patch) {
        try {
          const targetId = String(id || '').trim();
          if (!targetId) return;
          let found = false;
          const next = (Array.isArray(this.existingServices) ? this.existingServices : []).map((svc) => {
            if (svc && svc.id === targetId) {
              found = true;
              return { ...svc, ...patch };
            }
            return svc;
          });
          if (found) {
            this.existingServices = next;
            try { localStorage.setItem('wp.servicesCache', JSON.stringify({ ts: Date.now(), items: next })); } catch (_) { }
            if (targetId === this.selectedServiceId) {
              const updated = next.find(svc => svc && svc.id === targetId);
              if (updated) this.applyServiceDetails(updated, { force: true, focus: false });
            }
          }
        } catch (_) { }
      },

      queueSaveDetails(immediate = false) {
        if (this.isGuest) return;
        try {
          if (this.saveDetailsTimer) {
            clearTimeout(this.saveDetailsTimer);
            this.saveDetailsTimer = null;
          }
        } catch (_) { }
        if (!this.selectedServiceId) return;
        this.detailsDirty = true;
        if (immediate) {
          this.persistDetails();
          return;
        }
        this.saveDetailsTimer = setTimeout(() => this.persistDetails(), 600);
      },

      async persistDetails() {
        if (this.isGuest) return;
        try {
          if (this.saveDetailsTimer) {
            clearTimeout(this.saveDetailsTimer);
            this.saveDetailsTimer = null;
          }
        } catch (_) { }
        if (!this.selectedServiceId) return;
        this.savingDetails = true;
        this.detailsError = '';
        const payload = { ...this.form, id: this.selectedServiceId, scriptureText: this.scriptureText };
        try {
          const res = await callRpc('saveService', payload);
          const newId = res?.id || this.selectedServiceId;
          if (newId && newId !== this.selectedServiceId) {
            this.selectedServiceId = newId;
          }
          const patch = {
            date: this.form.date,
            time: this.form.time,
            type: this.form.type,
            leader: this.form.leader,
            preacher: this.form.preacher,
            scripture: this.form.scripture,
            scriptureText: this.scriptureText,
            theme: this.form.theme,
            keywords: this.form.keywords,
            notes: this.form.notes,
            suggestedSongs: this.form.suggestedSongs
          };
          this.updateCachedService(newId, patch);
          this.detailsDirty = false;
          this.savedAt = Date.now();
        } catch (e) {
          console.error(e);
          const msg = (e && e.message) ? e.message : 'Failed to save service details';
          this.detailsError = msg;
          try { notify(msg, 'error'); } catch (_) { }
        } finally {
          this.savingDetails = false;
        }
      },

      actionLabel() { return 'Save Service'; },

      queueSaveOrder(immediate = false) {
        if (this.isGuest) return;
        try {
          if (this.saveOrderTimer) {
            clearTimeout(this.saveOrderTimer);
            this.saveOrderTimer = null;
          }
        } catch (_) { }
        if (!this.selectedServiceId) return; // need a service id first
        if (immediate) { this.persistOrder(); return; }
        this.saveOrderTimer = setTimeout(() => this.persistOrder(), 800);
      },

      async persistOrder() {
        if (this.isGuest) return;
        if (!this.selectedServiceId) return;
        this.savingOrder = true;
        this.saveOrderError = '';
        try {
          const sid = this.selectedServiceId;
          await callRpc('saveOrder', { serviceId: sid, items: this.serializedOrder(), serviceDate: this.form?.date || '' });
          this.savedAt = Date.now();
        } catch (e) {
          console.error(e);
          this.saveOrderError = (e && e.message) ? e.message : 'Failed to save order';
        } finally {
          this.savingOrder = false;
        }
      }
    }
  }
</script>






