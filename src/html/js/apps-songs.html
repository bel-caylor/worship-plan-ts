<script>
  const SONGS_CACHE_KEY = '__wpSongsCache';
  let SONGS_BROWSER_HTML_PROMISE = null;
  const fetchSongsBrowserHtml = async () => {
    if (SONGS_BROWSER_HTML_PROMISE) return SONGS_BROWSER_HTML_PROMISE;
    if (typeof window === 'undefined' || !window.fetch) {
      SONGS_BROWSER_HTML_PROMISE = Promise.resolve('');
      return SONGS_BROWSER_HTML_PROMISE;
    }
    SONGS_BROWSER_HTML_PROMISE = window.fetch('songs-browser.html', { credentials: 'same-origin' })
      .then((res) => (res && res.ok ? res.text() : ''))
      .catch(() => '');
    return SONGS_BROWSER_HTML_PROMISE;
  };
  const getSongsCache = () => {
    try {
      const scope = typeof window !== 'undefined' ? window : globalThis;
      scope[SONGS_CACHE_KEY] = scope[SONGS_CACHE_KEY] || { rows: null, lastFetched: 0, pending: null };
      return scope[SONGS_CACHE_KEY];
    } catch (_) {
      return { rows: null, lastFetched: 0, pending: null };
    }
  };

  const starDebugLog = (...args) => {
    try {
      const scope = typeof window !== 'undefined' ? window : globalThis;
      if (!scope || !scope.__STAR_DEBUG__) return;
      console.log('[star-debug]', ...args);
    } catch (_) {}
  };
  const starDebugTrace = (...args) => {
    try {
      const scope = typeof window !== 'undefined' ? window : globalThis;
      if (!scope || !scope.__STAR_DEBUG__) return;
      console.trace('[star-debug]', ...args);
    } catch (_) {}
  };

  const createStarStore = () => {
    let orderState = [];
    const listeners = new Set();
    const makeSnapshot = () => {
      const list = orderState.slice();
      return {
        set: new Set(list),
        order: list
      };
    };
    const sanitizeOrder = (input) => {
      const seen = new Set();
      const output = [];
      (Array.isArray(input) ? input : []).forEach((key) => {
        const normalized = typeof key === 'string' ? key.trim().toLowerCase() : '';
        if (!normalized || seen.has(normalized)) return;
        seen.add(normalized);
        output.push(normalized);
      });
      return output;
    };
    const notify = () => {
      listeners.forEach((fn) => {
        try { fn(makeSnapshot()); } catch (_) {}
      });
    };
    return {
      get: makeSnapshot,
      subscribe(fn) {
        if (typeof fn !== 'function') return () => {};
        listeners.add(fn);
        try { fn(makeSnapshot()); } catch (_) {}
        return () => listeners.delete(fn);
      },
      update(updater) {
        if (typeof updater !== 'function') return;
        const draft = makeSnapshot();
        const next = updater(draft) || draft;
        orderState = sanitizeOrder(next.order);
        starDebugLog('store:update', orderState);
        notify();
      }
    };
  };
  const ensureStarStore = () => {
    try {
      const scope = typeof window !== 'undefined' ? window : globalThis;
      if (!scope.__SONG_STAR_STORE__) {
        scope.__SONG_STAR_STORE__ = createStarStore();
      }
      return scope.__SONG_STAR_STORE__;
    } catch (_) {
      return createStarStore();
    }
  };
  const SONG_STAR_STORE = ensureStarStore();
  try {
    if (typeof window !== 'undefined' && !window.__SONG_STAR_STORE_RESET__) {
      window.__SONG_STAR_STORE_RESET__ = true;
      SONG_STAR_STORE.update(() => ({
        order: []
      }));
    }
  } catch (_) {}
  function songsApp(mode = 'default') {
    const IS_GUEST = !!(window.__GUEST__);
    const normalizedMode = String(mode || '').toLowerCase();
    const isModal = normalizedMode === 'modal';
    const isEmbedded = normalizedMode === 'embedded';
    const songsCache = getSongsCache();
    const seededRows = (() => {
      if (Array.isArray(songsCache.rows) && songsCache.rows.length) return songsCache.rows;
      try {
        if (typeof window !== 'undefined' && Array.isArray(window.__ROWS__) && window.__ROWS__.length) {
          songsCache.rows = window.__ROWS__;
          songsCache.lastFetched = songsCache.lastFetched || Date.now();
          return songsCache.rows;
        }
      } catch (_) {}
      return [];
    })();
    const audioExts = new Set(['mp3','m4a','wav','aac','flac','ogg','wma','aiff','mid','midi']);
    const docRules = [
      { label: 'Guitar', patterns: [/gdoc\b/i, /\bguitar\b/i, /(^|[\s_-])g($|[\s_-])/i] },
      { label: 'Lyrics', patterns: [/wdoc\b/i, /\blyrics?\b/i, /(^|[\s_-])w($|[\s_-])/i] },
      { label: 'Bass', patterns: [/bdoc\b/i, /\bbass\b/i, /(^|[\s_-])b($|[\s_-])/i] }
    ];

    const splitSeasons = (val) => String(val ?? '').split(/[\/ ,;|]/g).map(s => s.trim()).filter(Boolean);
    const norm = (s) => String(s || '').toLowerCase();
    const title = (s) => String(s || '').replace(/\w\S*/g, w => w[0].toUpperCase() + w.slice(1).toLowerCase());
    const usageKey = (s) => String(s || '').toLowerCase().replace(/[^a-z0-9]+/g, '');
    const truthyFlag = (val) => /^y(es)?|true|1$/i.test(String(val ?? '').trim());
    const isFlagOn = (value) => {
      const normalized = String(value ?? '').trim().toLowerCase();
      return normalized === 'y' || normalized === 'yes' || normalized === 'true' || normalized === '1';
    };

    const makeSongForm = (row = {}) => ({
      Song: String(row?.Song || ''),
      Leader: String(row?.Leader || ''),
      Season: String(row?.Season || ''),
      Usage: String(row?.Usage || ''),
      Themes: String(row?.Themes || ''),
      Keywords: String(row?.Keywords || ''),
      Scriptures: String(row?.Scriptures || ''),
      Notes: String(row?.Notes || ''),
      Lyrics: String(row?.Lyrics || row?.['Lyrics (PD)'] || ''),
      Link: String(row?.Link || row?.link || ''),
      Sp: isFlagOn(row?.Sp ?? row?.sp ?? row?.Spanish ?? ''),
      Archive: isFlagOn(row?.Archive ?? row?.archive ?? row?.ARCHIVE ?? row?.Archived ?? '')
    });

    return {
      isGuest: IS_GUEST,
      isModalContext: isModal,
      isEmbedded,
      mobileListOpen: false,
      filtersOpen: false,
      songsCache,
      rows: Array.isArray(seededRows) ? seededRows : (window.__ROWS__ || []),
      filtered: [],
      selected: null,
      tableHeaders: ['Song','Last_Used'],
      starSnapshot: SONG_STAR_STORE.get(),

      seasons: [],
      selectedSeason: '',
      leaderOptions: [],
      selectedLeader: '',
      usageOptions: [],
      selectedUsage: '',
      seedTokens: [],

      opts: { allowChristmas: true },

      q: '',
      searchLyrics: true,
      spanishOnly: false,
      showArchived: false,
      sortKey: 'Last_Used',
      sortDir: 1,

      loading: false,
      error: '',

      mediaFiles: [],
      mediaLoading: false,
      mediaMessage: '',
      _aiTitleSet: null,
      _aiReasonMap: null,
      _defaultsTs: 0,
      showSongEditor: false,
      songEditorMode: 'create',
      songEditorError: '',
      songEditorSaving: false,
      songForm: makeSongForm(),
      editorOriginalName: '',
      _layoutBootstrapped: false,
      _pendingSelectTitle: '',
      _cleanupFns: [],

      async init() {
        await this.bootstrapLayout();
        await this.ensureRowsLoaded();

        this.buildFilters();

        this.$watch('q', () => this.render(true));
        this.$watch('selectedSeason', () => this.render(true));
        this.$watch('selectedLeader', () => this.render(true));
        this.$watch('searchLyrics', () => this.render(true));
        this.$watch('spanishOnly', () => this.render(true));
        this.$watch('showArchived', () => this.render(true));
        this.$watch('selectedUsage', () => this.render(true));
        this.render(true);

        this.syncDefaults(true);
        try {
          this.$watch(
            () => {
              try {
                return window.Alpine && typeof window.Alpine.store === 'function'
                  ? (window.Alpine.store('suggestDefaults')?.updatedAt || 0)
                  : 0;
              } catch (_) {
                return 0;
              }
            },
            () => this.syncDefaults()
          );
        } catch (_) {}
        if (this.isEmbedded) {
          try {
            window.dispatchEvent(new CustomEvent('embedded-songs-ready', { detail: { instance: this } }));
          } catch (_) { /* ignore */ }
        }
        const unsubscribeStars = SONG_STAR_STORE.subscribe((snapshot) => {
          this.starSnapshot = snapshot;
          this.render(false);
        });
        this._cleanupFns.push(() => unsubscribeStars && unsubscribeStars());
        this.registerTeardown();
      },

      buildFilters() {
        const bucket = new Map();
        for (const r of (this.rows || [])) {
          for (const tok of splitSeasons(r['Season'])) {
            const k = norm(tok); if (k) bucket.set(k, title(tok));
          }
        }
        if ((this.rows || []).some(r => !String(r['Season'] || '').trim())) bucket.set('__uncat__', 'Uncategorized');
        this.seasons = Array.from(bucket.entries()).sort((a,b)=>a[1].localeCompare(b[1])).map(([key,label])=>({key,label}));

        const leaderSet = new Set();
        for (const r of (this.rows || [])) {
          const L = Array.isArray(r._leaders) ? r._leaders : [];
          for (const name of L) leaderSet.add(name);
        }
        this.leaderOptions = Array.from(leaderSet).sort((a,b)=>a.localeCompare(b));

        const ctx = (window.APP_CTX || {});
        const preferred = Array.isArray(ctx.usageFilterChoices) ? ctx.usageFilterChoices : [];
        const seen = new Map();
        const add = (label) => {
          const k = usageKey(label);
          if (k && !seen.has(k)) seen.set(k, label);
        };
        for (const lab of preferred) add(lab);
        for (const r of (this.rows || [])) {
          const parts = String(r['Usage'] ?? '')
            .split(',')
            .map(s => s.trim())
            .filter(Boolean);
          for (const p of parts) add(p);
        }
        this.usageOptions = Array.from(seen.values());
      },

      async select(row) {
        this.selected = row;
        this.mediaFiles = [];
        this.mediaMessage = '';
        if (!row) return;
        const url = String((row && row._folderUrl) || '').trim();
        if (!url) {
          this.mediaMessage = 'No folder link available.';
          return;
        }
        await this.loadMediaForUrl(url);
        if (!this.isModalContext) {
          this.mobileListOpen = false;
        }
      },

      async loadMediaForUrl(url) {
        if (!url) {
          this.mediaFiles = [];
          this.mediaMessage = 'No folder link available.';
          return;
        }
        this.mediaLoading = true;
        try {
          const files = await callRpc('getFilesForFolderUrl', url);
          this.mediaFiles = Array.isArray(files) ? files : [];
          this.mediaMessage = this.mediaFiles.length ? '' : 'No files in folder.';
        } catch (e) {
          console.error(e);
          this.mediaFiles = [];
          this.mediaMessage = (e && e.message) ? e.message : 'Failed to load files.';
        } finally {
          this.mediaLoading = false;
        }
      },

      sort(h) {
        this.sortKey === h ? this.sortDir *= -1 : (this.sortKey = h, this.sortDir = 1);
        this.render(true);
      },

      headerLabel(key) {
        return key === 'Last_Used' ? 'Last' : key;
      },

      headerIcon(key) {
        if (this.sortKey !== key) return '&#8597;';
        return this.sortDir === 1 ? '&#9650;' : '&#9660;';
      },

      isSpanish(row) {
        if (!row || typeof row !== 'object') return false;
        const raw = row.Sp ?? row.sp ?? row['SP'] ?? row['Spanish'] ?? '';
        const val = String(raw || '').trim().toLowerCase();
        if (!val) return false;
        return val === 'y' || val === 'yes' || val === 'spanish' || val === 'true' || val === '1';
      },

      isArchived(row) {
        if (!row || typeof row !== 'object') return false;
        const raw = row.Archive ?? row.archive ?? row['ARCHIVE'] ?? row.Archived ?? row.archived ?? '';
        const val = String(raw || '').trim().toLowerCase();
        if (!val) return false;
        return val === 'y' || val === 'yes' || val === 'true' || val === '1';
      },

      starOrder() {
        try {
          const snap = this.starSnapshot || SONG_STAR_STORE.get();
          const list = Array.isArray(snap?.order) ? snap.order : [];
          return list.slice();
        } catch (_) {
          return [];
        }
      },

      starSet() {
        try {
          const snap = this.starSnapshot || SONG_STAR_STORE.get();
          if (snap?.set instanceof Set) return new Set(snap.set);
        } catch (_) {
        }
        return new Set();
      },

      hasStars() {
        return this.starOrder().length > 0;
      },

      starredRows() {
        const order = this.starOrder();
        if (!order.length) return [];
        const rows = Array.isArray(this.rows) ? this.rows : [];
        const lookup = new Map();
        rows.forEach((row) => {
          const key = this.normalizeTitle(row?.Song);
          if (key && !lookup.has(key)) lookup.set(key, row);
        });
        const seen = new Set();
        const out = [];
        for (const key of order) {
          if (!key || seen.has(key)) continue;
          const row = lookup.get(key);
          if (row) {
            out.push(row);
            seen.add(key);
          }
        }
        return out;
      },

      starSet() {
        return new Set(this.starOrder());
      },

      registerTeardown() {
        const root = this.$el;
        if (!root || root.__songsCleanupAttached) return;
        root.__songsCleanupAttached = true;
        root.addEventListener('alpine:destroy', () => {
          this._cleanupFns.forEach(fn => {
            try { fn(); } catch (_) {}
          });
          this._cleanupFns = [];
        });
      },

      render(resetSelection = false) {
        const wantLeader = (this.selectedLeader || '').trim();
        const wantUsage = (this.selectedUsage || '').trim();
        const q = (this.q || '').toLowerCase().trim();
        const tokens = q ? q.split(/[,\s]+/).map(t => t.trim()).filter(Boolean) : [];
        const want = this.selectedSeason;
        const baseFields = ['Song','Themes','Season','Keywords','Scriptures','Notes'];
        const fields = this.searchLyrics ? [...baseFields, 'Lyrics','Lyrics (PD)'] : baseFields;

        let out = (this.rows || []).filter(r => {
          if (want) {
            const toks = splitSeasons(r['Season']).map(norm);
            const ok = want === '__uncat__' ? toks.length === 0 : toks.includes(want);
            if (!ok) return false;
          }
          if (this.opts && this.opts.allowChristmas === false) {
            const seasonText = String(r['Season'] || '').toLowerCase();
            if (/(christ|advent)/.test(seasonText)) return false;
          }
          if (wantLeader) {
            const L = Array.isArray(r._leaders) ? r._leaders : [];
            if (!L.includes(wantLeader)) return false;
          }
          if (this.spanishOnly && !this.isSpanish(r)) return false;
          if (!this.showArchived && this.isArchived(r)) return false;
          if (wantUsage) {
            const want = usageKey(wantUsage);
            const toks = String(r['Usage'] ?? '')
              .split(',')
              .map(t => usageKey(t))
              .filter(Boolean);
            if (!toks.includes(want)) return false;
          }
          if (!tokens.length) return true;
          for (const f of fields) {
            const v = r[f];
            if (v != null) {
              const val = String(v).toLowerCase();
              for (const tok of tokens) {
                if (val.includes(tok)) return true;
              }
            }
          }
          return false;
        });

        if (this.sortKey) {
          const k = this.sortKey, d = this.sortDir;
          const toTime = (v) => {
            if (v instanceof Date) return v.getTime();
            const s = String(v || '').trim();
            const d1 = new Date(s);
            return isNaN(d1.getTime()) ? Number.POSITIVE_INFINITY : d1.getTime();
          };
          out = out.slice().sort((a,b) => {
            if (k === 'Last_Used') {
              const at = toTime(a[k]);
              const bt = toTime(b[k]);
              return (at - bt) * d;
            }
            const av = (a[k] ?? '').toString().toLowerCase();
            const bv = (b[k] ?? '').toString().toLowerCase();
            return av < bv ? -1 * d : av > bv ? 1 * d : 0;
          });
        }

        const aiOnly = [];
        const remainder = [];
        for (const row of out) {
          if (this.isAiSuggestion(row)) {
            aiOnly.push(row);
          } else {
            remainder.push(row);
          }
        }
        out = aiOnly.concat(remainder);

        this.filtered = out;
        let target = null;
        if (this._pendingSelectTitle) {
          const needle = this._pendingSelectTitle;
          target = out.find(r => this.normalizeTitle(r?.Song) === needle) || null;
        }
        if (resetSelection || !this.selected || !out.includes(this.selected)) {
          this.selected = target || out[0] || null;
        } else if (target) {
          this.selected = target;
        }
        this._pendingSelectTitle = '';
      },

      isStarred(row) {
        if (!row) return false;
        const key = this.normalizeTitle(row.Song || row.song);
        const set = this.starSet();
        return !!(key && set.has(key));
      },

      toggleStar(row, evt = null) {
        const trusted = !!(evt && evt.isTrusted !== false);
        const fromStarControl = (() => {
          if (!evt) return false;
          const inspect = (node) => (node && typeof node.closest === 'function'
            ? node.closest('[data-star-toggle]')
            : null);
          return !!(inspect(evt.target) || inspect(evt.currentTarget));
        })();
        if (!trusted || !fromStarControl) {
          starDebugLog('toggleStar: ignored event', {
            song: row?.Song || row?.song || '',
            trusted,
            fromStarControl
          });
          return;
        }
        starDebugLog('toggle', row?.Song || row?.song || '');
        if (!row) return;
        const key = this.normalizeTitle(row.Song || row.song);
        if (!key) return;
        starDebugTrace('toggleStar', key, row && row.Song);
        SONG_STAR_STORE.update((snapshot) => {
          const existing = Array.isArray(snapshot?.order) ? snapshot.order : [];
          const without = existing.filter(k => k !== key);
          const already = snapshot?.set instanceof Set ? snapshot.set.has(key) : existing.includes(key);
          const nextOrder = already ? without : [key, ...without];
          return { order: nextOrder };
        });
      },

      clearStarred() {
        if (!this.hasStars()) return;
        starDebugLog('clearStarred');
        SONG_STAR_STORE.update(() => ({
          order: []
        }));
      },

      setAiSongTitles(titles) {
        const entries = Array.isArray(titles) ? titles : [];
        const titleSet = new Set();
        const reasonMap = new Map();
        for (const entry of entries) {
          let title = '';
          let reason = '';
          if (typeof entry === 'string') {
            title = entry;
          } else if (entry && typeof entry === 'object') {
            title = entry.title || entry.name || entry.song || '';
            reason = entry.reason || '';
          }
          const normalized = this.normalizeTitle(title);
          if (!normalized) continue;
          titleSet.add(normalized);
          if (reason) reasonMap.set(normalized, reason);
        }
        this._aiTitleSet = titleSet.size ? titleSet : null;
        this._aiReasonMap = reasonMap.size ? reasonMap : null;
        this.render(true);
      },

      isAiSuggestion(row) {
        if (!row || !this._aiTitleSet) return false;
        return this._aiTitleSet.has(this.normalizeTitle(row?.Song || ''));
      },

      aiReasonForSong(row) {
        if (!row || !this._aiReasonMap) return '';
        const key = this.normalizeTitle(row?.Song || row?.song);
        if (!key) return '';
        return this._aiReasonMap.get(key) || '';
      },

      format(v) {
        if (typeof v === 'string' && /^\d{4}-\d{2}-\d{2}T/.test(v)) {
          const d = new Date(v);
          return d.toLocaleDateString();
        }
        return v ?? '';
      },

      friendlyMediaName(file) {
        const raw = String(file?.name || '').trim();
        if (!raw) return 'File';
        const normalizedRaw = this.normalizeMediaSymbols(raw);
        const withoutSong = this.stripSongTitle(normalizedRaw);
        const base = this.removeExtension(withoutSong);
        const trimmed = this.trimDelimiters(base);
        if (!trimmed) return raw;
        const cleaned = this.removeTrailingSongReference(trimmed);
        if (this.isAudioFile(file)) return this.removeTrailingSongReference(this.audioLabelFrom(cleaned)) || 'Audio';
        const doc = this.docLabelFrom(cleaned);
        if (doc) return this.removeTrailingSongReference(doc);
        return this.removeTrailingSongReference(this.normalizeResidual(cleaned)) || raw;
      },

      stripSongTitle(name) {
        const song = this.normalizeMediaSymbols(String(this.selected?.Song || '').trim());
        if (!song) return name;
        const escaped = song.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        let result = name;
        const leading = new RegExp(`^${escaped}(?:[\\s._-]+|$)`, 'i');
        result = result.replace(leading, '');
        const trailing = new RegExp(`(?:[\\s._-]+|^)${escaped}(?:[\\s._-]+)?$`, 'i');
        result = result.replace(trailing, '');
        return result.trim();
      },

      removeExtension(name) {
        return name.replace(/\.[^.]+$/, '');
      },

      trimDelimiters(str) {
        return String(str || '').replace(/^[\s._-]+/, '').replace(/[\s._-]+$/, '');
      },

      normalizeResidual(str) {
        let out = String(str || '');
        out = this.normalizeMediaSymbols(out);
        out = out.replace(/[_]+/g, ' ');
        out = out.replace(/\s{2,}/g, ' ');
        out = out.replace(/\s*\(/g, ' (').replace(/\s*\)/g, ')');
        return out.trim();
      },

      normalizeMediaSymbols(str) {
        return String(str || '')
          .replace(/[’‘]/g, "'")
          .replace(/[“”]/g, '"')
          .replace(/[‐‑–—]/g, '-');
      },

      removeTrailingSongReference(str) {
        const song = this.normalizeMediaSymbols(String(this.selected?.Song || '').trim());
        if (!song) return str;
        const escaped = song.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const pattern = new RegExp(`(?:[\\s._-]+|^)${escaped}(?:[\\s._-]+)?$`, 'i');
        let result = String(str || '').replace(pattern, '');
        // Handle cases with duplicate whitespace after removal
        result = result.replace(pattern, '');
        return result.trim();
      },

      docLabelFrom(str) {
        for (const rule of docRules) {
          for (const rx of rule.patterns) {
            if (rx.test(str)) {
              const detail = this.normalizeResidual(str.replace(rx, ' '));
              return detail ? `${rule.label} ${detail}` : rule.label;
            }
          }
        }
        return '';
      },

      isAudioFile(file) {
        const mime = String(file?.mimeType || '').toLowerCase();
        if (mime.startsWith('audio/')) return true;
        const name = String(file?.name || '');
        const ext = (name.split('.').pop() || '').toLowerCase();
        return audioExts.has(ext);
      },

      audioLabelFrom(str) {
        const parts = this.extractAudioParts(str);
        if (parts.date && parts.detail) return `${parts.date} - ${parts.detail}`;
        if (parts.date) return parts.date;
        return parts.detail || 'Audio';
      },

      extractAudioParts(str) {
        let working = String(str || '');
        let date = '';
        const paren = /\(([^)]+)\)\s*$/.exec(working);
        if (paren) {
          date = paren[1].trim();
          working = `${working.slice(0, paren.index)}${working.slice(paren.index + paren[0].length)}`;
        }
        if (!date) {
          const compact = /(\d{1,2}[A-Za-z]{3}\d{2,4})/.exec(working);
          if (compact) {
            date = compact[1];
            working = working.replace(compact[0], ' ');
          }
        }
        if (!date) {
          const monthYear = /([A-Za-z]{3,9}\s?\d{2,4})/.exec(working);
          if (monthYear) {
            date = monthYear[1].trim();
            working = working.replace(monthYear[0], ' ');
          }
        }
        const detail = this.normalizeResidual(working);
        return { date: date.trim(), detail };
      },

      async copy(text) { try { await navigator.clipboard.writeText(String(text ?? '')); } catch { } },

      applySuggestion(index, payload) {
        try {
          const name = (payload && payload.name) ? String(payload.name) : String(this.selected?.Song || '');
          const ev = new CustomEvent('use-song', { detail: { index, name }, bubbles: true });
          this.$el.dispatchEvent(ev);
        } catch (_) { }
      },

      openSongLink(url) {
        const target = String(url || '').trim();
        if (!target) return;
        try {
          const win = window.open(target, 'song-link', 'width=1100,height=720,resizable=yes,scrollbars=yes');
          if (win) {
            try { win.opener = null; } catch (_) { }
          } else {
            window.open(target, '_blank');
          }
        } catch (_) {
          window.open(target, '_blank');
        }
      },

      fileIcon(mimeType) {
        const type = String(mimeType || '').toLowerCase();
        if (!type) return '\uD83D\uDCC4'; // page facing up
        if (type.startsWith('audio/')) return '\uD83C\uDFB5'; // musical note
        if (type.startsWith('video/')) return '\uD83C\uDFA5'; // movie camera
        if (type.includes('pdf')) return '\uD83D\uDCC4';
        if (type.includes('presentation')) return '\uD83D\uDCCB'; // clipboard
        if (type.includes('spreadsheet') || type.includes('excel')) return '\uD83D\uDCC8'; // chart with upwards trend
        if (type.includes('word') || type.includes('document')) return '\uD83D\uDCC3'; // page with curl
        return '\uD83D\uDCC4';
      },

      tokenize(input) {
        return Array.from(
          new Set(
            String(input || '')
              .split(/[,\s]+/)
              .map(t => t.trim())
              .filter(Boolean)
              .map(t => t.toLowerCase())
          )
        );
      },

      searchTokens() {
        return this.tokenize(this.q);
      },

      highlightTokens() {
        const tokens = new Set(this.searchTokens());
        (this.seedTokens || []).forEach(tok => tokens.add(tok));
        return Array.from(tokens);
      },

      escapeHtml(str) {
        return String(str || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      },

      highlightedLyrics() {
        const base = this.selected?.Lyrics || this.selected?.['Lyrics (PD)'] || '';
        if (!base) return this.escapeHtml('(No lyrics)');
        const tokens = this.highlightTokens();
        let html = this.escapeHtml(base);
        if (tokens.length) {
          const parts = tokens
            .map(tok => tok.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
            .filter(Boolean);
          if (parts.length) {
            const rx = new RegExp(`(${parts.join('|')})`, 'gi');
            html = html.replace(rx, '<mark class="px-0.5 bg-yellow-200 text-gray-900 rounded">$1</mark>');
          }
        }
        return html;
      },

      normalizeTitle(value) {
        return String(value || '')
          .toLowerCase()
          .replace(/[^a-z0-9\s]+/g, ' ')
          .replace(/\s+/g, ' ')
          .trim();
      },

      assignRowUids(rows) {
        if (!Array.isArray(rows)) return;
        rows.forEach((row, idx) => {
          if (!row || typeof row !== 'object') return;
          if (row._uid) return;
          const base = this.normalizeTitle(row.Song || row.song) || 'row';
          const last = String(row.Last_Used || row.last_used || '');
          row._uid = `${base}::${last}::${idx}`;
        });
      },

      findSongByName(name) {
        const needle = this.normalizeTitle(name);
        if (!needle) return null;
        return (this.rows || []).find(r => this.normalizeTitle(r?.Song) === needle) || null;
      },

      queueSelectSong(name) {
        this._pendingSelectTitle = this.normalizeTitle(name);
      },

      async focusOnSong(name, { clearFilters = true } = {}) {
        const title = this.normalizeTitle(name);
        if (!title) return false;
        if (typeof this.ensureRowsLoaded === 'function') {
          try { await this.ensureRowsLoaded(); } catch (_) {}
        }
        this.queueSelectSong(title);
        const setIfNeeded = (key, value) => {
          if (this[key] !== value) this[key] = value;
        };
        if (clearFilters) {
          setIfNeeded('selectedSeason', '');
          setIfNeeded('selectedLeader', '');
          setIfNeeded('selectedUsage', '');
          setIfNeeded('spanishOnly', false);
          setIfNeeded('showArchived', true);
        }
        if (Array.isArray(this.seedTokens) && this.seedTokens.length) {
          this.seedTokens = [];
        }
        if (this.q) {
          this.q = '';
        }
        this.render(true);
        return true;
      },

      songBrowserPreviewContext() {
        const selected = this.selected;
        if (!selected) return { hasSong: false };
        const stats = {
          uses: selected.Uses || selected.uses || '',
          usage: selected.Usage || selected.usage || '',
          years: selected.Years_Used || selected.years_used || '',
          lastUsed: selected.Last_Used || selected.last_used || '',
          firstUsed: selected.First_Used || selected.first_used || ''
        };
        const mediaList = Array.isArray(this.mediaFiles)
          ? this.mediaFiles.map(file => ({
              url: file.url,
              label: this.friendlyMediaName(file),
              icon: this.fileIcon(file.mimeType)
            }))
          : [];
        const aiReason = this.aiReasonForSong(selected);
        return {
          hasSong: true,
          song: selected,
          reason: selected.Reason || '',
          aiReason,
          leader: selected.Leader || '',
          season: selected.Season || '',
          themes: selected.Themes || '',
          scriptures: selected.Scriptures || '',
          keywords: selected.Keywords || '',
          lyrics: selected.Lyrics || selected['Lyrics (PD)'] || '',
          isModalContext: this.isModalContext,
          starred: this.isStarred(selected),
          stats,
          link: selected.Link || selected.link || '',
          folderUrl: selected._folderUrl || selected.folderUrl || '',
          copyLyrics: (evt) => {
            if (!evt || evt.isTrusted === false) return;
            try {
              const lyr = selected?.Lyrics || selected?.['Lyrics (PD)'] || '';
              if (!lyr) return;
              navigator.clipboard?.writeText(lyr);
              notify && notify('Lyrics copied to clipboard.', 'success', 2000);
            } catch (_) {
              notify && notify('Unable to copy lyrics.', 'error', 2000);
            }
          },
          useSong: () => {
            if (this.isModalContext && selected?.Song) {
              this.$dispatch('use-song', { index: this.$root?.suggestTargetIndex, name: selected.Song });
            }
          },
          mediaFiles: mediaList,
          mediaLoading: this.mediaLoading,
          mediaMessage: this.mediaMessage,
          onToggleStar: (evt) => this.toggleStar(selected, evt)
        };
      },

      openSongEditor(mode = 'create') {
        if (this.isGuest) {
          this.error = 'View only mode. Sign in to edit songs.';
          return;
        }
        const nextMode = mode === 'edit' ? 'edit' : 'create';
        if (nextMode === 'edit' && !this.selected) {
          this.error = 'Select a song to edit first.';
          return;
        }
        this.songEditorMode = nextMode;
        this.songEditorError = '';
        this.songForm = nextMode === 'edit' ? makeSongForm(this.selected || {}) : makeSongForm();
        this.editorOriginalName = nextMode === 'edit' ? String(this.selected?.Song || '') : '';
        this.showSongEditor = true;
        this.$nextTick(() => {
          try { this.$refs?.songTitle?.focus(); } catch (_) {}
        });
      },

      cancelSongEditor() {
        if (this.songEditorSaving) return;
        this.showSongEditor = false;
        this.songEditorError = '';
      },

      buildSongPayload() {
        const form = this.songForm || {};
        return {
          Song: String(form.Song || '').trim(),
          Leader: String(form.Leader || '').trim(),
          Season: String(form.Season || '').trim(),
          Usage: String(form.Usage || '').trim(),
          Themes: String(form.Themes || '').trim(),
          Keywords: String(form.Keywords || '').trim(),
          Scriptures: String(form.Scriptures || '').trim(),
          Notes: String(form.Notes || '').trim(),
          Lyrics: String(form.Lyrics || ''),
          Link: String(form.Link || '').trim(),
          Sp: form.Sp ? 'Y' : '',
          Archive: form.Archive ? 'Y' : ''
        };
      },

      async saveSongEditor() {
        if (this.isGuest) {
          this.songEditorError = 'View only mode. Sign in to edit songs.';
          return;
        }
        if (this.songEditorSaving) return;
        const payload = this.buildSongPayload();
        if (!payload.Song) {
          this.songEditorError = 'Song title is required.';
          return;
        }
        this.songEditorSaving = true;
        this.songEditorError = '';
        try {
          const res = await callRpc('saveSongEntry', {
            originalName: this.songEditorMode === 'edit' ? this.editorOriginalName : '',
            data: payload
          });
          if (Array.isArray(res?.items)) {
            this.updateRows(res.items, { skipRender: true });
            this.buildFilters();
            this.render(true);
            const match = this.findSongByName(payload.Song);
            if (match) await this.select(match);
          }
          this.showSongEditor = false;
        } catch (e) {
          console.error(e);
          this.songEditorError = (e && e.message) ? e.message : 'Unable to save song.';
        } finally {
          this.songEditorSaving = false;
        }
      },

      async bootstrapLayout() {
        if (this._layoutBootstrapped) return;
        const host = (this.$refs && this.$refs.browserHost) ? this.$refs.browserHost : null;
        if (!host) return;
        const initTree = () => {
          try {
            if (window.Alpine && typeof window.Alpine.initTree === 'function') {
              window.Alpine.initTree(host);
            }
          } catch (_) {}
        };
        try {
          const tpl = document.getElementById('songs-browser-template');
          if (tpl && tpl.content) {
            const fragment = tpl.content.cloneNode(true);
            host.innerHTML = '';
            host.appendChild(fragment);
            this._layoutBootstrapped = true;
            initTree();
            return;
          }
        } catch (_) {}
        try {
          const html = await fetchSongsBrowserHtml();
          if (html) {
            host.innerHTML = html;
            this._layoutBootstrapped = true;
            initTree();
          }
        } catch (err) {
          console.error('Failed to bootstrap songs layout', err);
        }
      },

      updateRows(rows, opts = {}) {
        if (!Array.isArray(rows)) return;
        this.rows = rows;
        this.syncCacheFromRows(rows);
        if (!opts.skipRender) this.render(true);
      },

      syncCacheFromRows(rows) {
        const list = Array.isArray(rows) ? rows : [];
        this.assignRowUids(list);
        if (this.songsCache) {
          this.songsCache.rows = list;
          this.songsCache.lastFetched = Date.now();
        }
        try {
          if (typeof window !== 'undefined') window.__ROWS__ = list;
        } catch (_) {}
      },

      async ensureRowsLoaded() {
        const cache = this.songsCache || {};
        if (Array.isArray(this.rows) && this.rows.length) {
          this.syncCacheFromRows(this.rows);
          return;
        }
        if (Array.isArray(cache.rows) && cache.rows.length) {
          this.rows = cache.rows;
          this.assignRowUids(this.rows);
          return;
        }
        if (cache.pending) {
          this.loading = true;
          try {
            await cache.pending;
            this.rows = Array.isArray(cache.rows) ? cache.rows : [];
            this.syncCacheFromRows(this.rows);
          } catch (e) {
            if (!this.isGuest) this.error = 'Failed to load songs';
          } finally {
            this.loading = false;
          }
          return;
        }
        this.loading = true;
        cache.pending = (async () => {
          try {
            const r = await callRpc('getSongsForView', null);
            if (Array.isArray(r)) {
              this.assignRowUids(r);
              cache.rows = r;
              cache.lastFetched = Date.now();
              try {
                if (typeof window !== 'undefined') window.__ROWS__ = r;
              } catch (_) {}
            } else {
              cache.rows = [];
            }
            return cache.rows;
          } finally {
            cache.pending = null;
          }
        })();
        try {
          await cache.pending;
          this.rows = Array.isArray(cache.rows) ? cache.rows : [];
          this.assignRowUids(this.rows);
          this.syncCacheFromRows(this.rows);
        } catch (e) {
          if (!this.isGuest) this.error = 'Failed to load songs';
        } finally {
          this.loading = false;
        }
      },

      applyDefaults(payload = {}) {
        const data = (payload && typeof payload === 'object') ? payload : {};
        const has = (k) => Object.prototype.hasOwnProperty.call(data, k);
        const normalize = (v) => typeof v === 'string' ? v : '';
        const ensureOption = (list, value) => {
          if (!value) return Array.isArray(list) ? list : [];
          const arr = Array.isArray(list) ? list.slice() : [];
          if (!arr.includes(value)) arr.unshift(value);
          return arr;
        };

        let shouldRender = false;

        if (has('allowChristmas')) {
          const flag = !!data.allowChristmas;
          if (!this.opts || this.opts.allowChristmas !== flag) {
            this.opts = Object.assign({}, this.opts || {}, { allowChristmas: flag });
            shouldRender = true;
          }
        } else if (data.options && typeof data.options === 'object') {
          this.opts = Object.assign({}, this.opts || {}, data.options);
          shouldRender = true;
        }

        if (has('seed')) {
          const next = normalize(data.seed);
          this.seedTokens = this.tokenize(next);
          if (this.q !== next) this.q = next;
        }

        if (has('leader')) {
          const leader = normalize(data.leader);
          this.leaderOptions = ensureOption(this.leaderOptions, leader);
          if (this.selectedLeader !== leader) this.selectedLeader = leader;
        }

        if (has('usage')) {
          const usage = normalize(data.usage);
          this.usageOptions = ensureOption(this.usageOptions, usage);
          if (this.selectedUsage !== usage) this.selectedUsage = usage;
        }

        if (shouldRender) this.render(true);
      },

      syncDefaults(force = false) {
        if (this.isModalContext) return;
        try {
          if (!window.Alpine || typeof window.Alpine.store !== 'function') return;
          const store = window.Alpine.store('suggestDefaults');
          if (!store) return;
          const ts = Number(store.updatedAt || 0);
          if (!force && ts === this._defaultsTs) return;
          this._defaultsTs = ts;
          this.applyDefaults({
            seed: store.seed ?? '',
            leader: store.leader ?? '',
            usage: store.usage ?? '',
            allowChristmas: store.allowChristmas
          });
        } catch (_) {}
      }
    }
  }
</script>
