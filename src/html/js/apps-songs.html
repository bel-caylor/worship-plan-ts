<script>
  function songsApp(mode = 'default') {
    const IS_GUEST = !!(window.__GUEST__);
    const normalizedMode = String(mode || '').toLowerCase();
    const isModal = normalizedMode === 'modal';
    const audioExts = new Set(['mp3','m4a','wav','aac','flac','ogg','wma','aiff','mid','midi']);
    const docRules = [
      { label: 'Guitar', patterns: [/gdoc\b/i, /\bguitar\b/i, /(^|[\s_-])g($|[\s_-])/i] },
      { label: 'Lyrics', patterns: [/wdoc\b/i, /\blyrics?\b/i, /(^|[\s_-])w($|[\s_-])/i] },
      { label: 'Bass', patterns: [/bdoc\b/i, /\bbass\b/i, /(^|[\s_-])b($|[\s_-])/i] }
    ];

    const splitSeasons = (val) => String(val ?? '').split(/[\/ ,;|]/g).map(s => s.trim()).filter(Boolean);
    const norm = (s) => String(s || '').toLowerCase();
    const title = (s) => String(s || '').replace(/\w\S*/g, w => w[0].toUpperCase() + w.slice(1).toLowerCase());
    const usageKey = (s) => String(s || '').toLowerCase().replace(/[^a-z0-9]+/g, '');
    const truthyFlag = (val) => /^y(es)?|true|1$/i.test(String(val ?? '').trim());
    const isFlagOn = (value) => {
      const normalized = String(value ?? '').trim().toLowerCase();
      return normalized === 'y' || normalized === 'yes' || normalized === 'true' || normalized === '1';
    };

    const makeSongForm = (row = {}) => ({
      Song: String(row?.Song || ''),
      Leader: String(row?.Leader || ''),
      Season: String(row?.Season || ''),
      Usage: String(row?.Usage || ''),
      Themes: String(row?.Themes || ''),
      Keywords: String(row?.Keywords || ''),
      Scriptures: String(row?.Scriptures || ''),
      Notes: String(row?.Notes || ''),
      Lyrics: String(row?.Lyrics || row?.['Lyrics (PD)'] || ''),
      Link: String(row?.Link || row?.link || ''),
      Sp: isFlagOn(row?.Sp ?? row?.sp ?? row?.Spanish ?? ''),
      Archive: isFlagOn(row?.Archive ?? row?.archive ?? row?.ARCHIVE ?? row?.Archived ?? '')
    });

    return {
      isGuest: IS_GUEST,
      isModalContext: isModal,
      mobileListOpen: false,
      filtersOpen: false,
      rows: window.__ROWS__ || [],
      filtered: [],
      selected: null,
      tableHeaders: ['Song','Last_Used'],

      seasons: [],
      selectedSeason: '',
      leaderOptions: [],
      selectedLeader: '',
      usageOptions: [],
      selectedUsage: '',

      opts: { allowChristmas: true },

      q: '',
      searchLyrics: true,
      spanishOnly: false,
      showArchived: false,
      sortKey: 'Last_Used',
      sortDir: 1,

      loading: false,
      error: '',

      mediaFiles: [],
      mediaLoading: false,
      mediaMessage: '',

      _defaultsTs: 0,
      showSongEditor: false,
      songEditorMode: 'create',
      songEditorError: '',
      songEditorSaving: false,
      songForm: makeSongForm(),
      editorOriginalName: '',

      async init() {
        if (!Array.isArray(this.rows) || !this.rows.length) {
          this.loading = true;
          try {
            const r = await callRpc('getSongsForView', null);
            if (Array.isArray(r)) this.rows = r;
          } catch (e) {
            this.error = this.isGuest ? '' : 'Failed to load songs';
          } finally {
            this.loading = false;
          }
        }

        this.buildFilters();
        if (typeof window !== 'undefined' && window.innerWidth < 768) {
          this.mobileListOpen = true;
        }

        this.$watch('q', () => this.render(true));
        this.$watch('selectedSeason', () => this.render(true));
        this.$watch('selectedLeader', () => this.render(true));
        this.$watch('searchLyrics', () => this.render(true));
        this.$watch('spanishOnly', () => this.render(true));
        this.$watch('showArchived', () => this.render(true));
        this.$watch('selectedUsage', () => this.render(true));
        this.render(true);

        this.syncDefaults(true);
        try {
          this.$watch(
            () => {
              try {
                return window.Alpine && typeof window.Alpine.store === 'function'
                  ? (window.Alpine.store('suggestDefaults')?.updatedAt || 0)
                  : 0;
              } catch (_) {
                return 0;
              }
            },
            () => this.syncDefaults()
          );
        } catch (_) {}
      },

      buildFilters() {
        const bucket = new Map();
        for (const r of (this.rows || [])) {
          for (const tok of splitSeasons(r['Season'])) {
            const k = norm(tok); if (k) bucket.set(k, title(tok));
          }
        }
        if ((this.rows || []).some(r => !String(r['Season'] || '').trim())) bucket.set('__uncat__', 'Uncategorized');
        this.seasons = Array.from(bucket.entries()).sort((a,b)=>a[1].localeCompare(b[1])).map(([key,label])=>({key,label}));

        const leaderSet = new Set();
        for (const r of (this.rows || [])) {
          const L = Array.isArray(r._leaders) ? r._leaders : [];
          for (const name of L) leaderSet.add(name);
        }
        this.leaderOptions = Array.from(leaderSet).sort((a,b)=>a.localeCompare(b));

        const ctx = (window.APP_CTX || {});
        const preferred = Array.isArray(ctx.usageFilterChoices) ? ctx.usageFilterChoices : [];
        const seen = new Map();
        const add = (label) => {
          const k = usageKey(label);
          if (k && !seen.has(k)) seen.set(k, label);
        };
        for (const lab of preferred) add(lab);
        for (const r of (this.rows || [])) {
          const parts = String(r['Usage'] ?? '')
            .split(',')
            .map(s => s.trim())
            .filter(Boolean);
          for (const p of parts) add(p);
        }
        this.usageOptions = Array.from(seen.values());
      },

      async select(row) {
        this.selected = row;
        this.mediaFiles = [];
        this.mediaMessage = '';
        if (!row) return;
        const url = String((row && row._folderUrl) || '').trim();
        if (!url) {
          this.mediaMessage = 'No folder link available.';
          return;
        }
        await this.loadMediaForUrl(url);
        if (!this.isModalContext) {
          this.mobileListOpen = false;
        }
      },

      async loadMediaForUrl(url) {
        if (!url) {
          this.mediaFiles = [];
          this.mediaMessage = 'No folder link available.';
          return;
        }
        this.mediaLoading = true;
        try {
          const files = await callRpc('getFilesForFolderUrl', url);
          this.mediaFiles = Array.isArray(files) ? files : [];
          this.mediaMessage = this.mediaFiles.length ? '' : 'No files in folder.';
        } catch (e) {
          console.error(e);
          this.mediaFiles = [];
          this.mediaMessage = (e && e.message) ? e.message : 'Failed to load files.';
        } finally {
          this.mediaLoading = false;
        }
      },

      sort(h) {
        this.sortKey === h ? this.sortDir *= -1 : (this.sortKey = h, this.sortDir = 1);
        this.render(true);
      },

      headerLabel(key) {
        return key === 'Last_Used' ? 'Last Used' : key;
      },

      headerIcon(key) {
        if (this.sortKey !== key) return '&#8597;';
        return this.sortDir === 1 ? '&#9650;' : '&#9660;';
      },

      isSpanish(row) {
        if (!row || typeof row !== 'object') return false;
        const raw = row.Sp ?? row.sp ?? row['SP'] ?? row['Spanish'] ?? '';
        const val = String(raw || '').trim().toLowerCase();
        if (!val) return false;
        return val === 'y' || val === 'yes' || val === 'spanish' || val === 'true' || val === '1';
      },

      isArchived(row) {
        if (!row || typeof row !== 'object') return false;
        const raw = row.Archive ?? row.archive ?? row['ARCHIVE'] ?? row.Archived ?? row.archived ?? '';
        const val = String(raw || '').trim().toLowerCase();
        if (!val) return false;
        return val === 'y' || val === 'yes' || val === 'true' || val === '1';
      },

      render(resetSelection = false) {
        const wantLeader = (this.selectedLeader || '').trim();
        const wantUsage = (this.selectedUsage || '').trim();
        const q = (this.q || '').toLowerCase().trim();
        const tokens = q ? q.split(/[,\s]+/).map(t => t.trim()).filter(Boolean) : [];
        const want = this.selectedSeason;
        const baseFields = ['Song','Themes','Season','Keywords','Scriptures','Notes'];
        const fields = this.searchLyrics ? [...baseFields, 'Lyrics','Lyrics (PD)'] : baseFields;

        let out = (this.rows || []).filter(r => {
          if (want) {
            const toks = splitSeasons(r['Season']).map(norm);
            const ok = want === '__uncat__' ? toks.length === 0 : toks.includes(want);
            if (!ok) return false;
          }
          if (this.opts && this.opts.allowChristmas === false) {
            const seasonText = String(r['Season'] || '').toLowerCase();
            if (/(christ|advent)/.test(seasonText)) return false;
          }
          if (wantLeader) {
            const L = Array.isArray(r._leaders) ? r._leaders : [];
            if (!L.includes(wantLeader)) return false;
          }
          if (this.spanishOnly && !this.isSpanish(r)) return false;
          if (!this.showArchived && this.isArchived(r)) return false;
          if (wantUsage) {
            const want = usageKey(wantUsage);
            const toks = String(r['Usage'] ?? '')
              .split(',')
              .map(t => usageKey(t))
              .filter(Boolean);
            if (!toks.includes(want)) return false;
          }
          if (!tokens.length) return true;
          for (const f of fields) {
            const v = r[f];
            if (v != null) {
              const val = String(v).toLowerCase();
              for (const tok of tokens) {
                if (val.includes(tok)) return true;
              }
            }
          }
          return false;
        });

        if (this.sortKey) {
          const k = this.sortKey, d = this.sortDir;
          const toTime = (v) => {
            if (v instanceof Date) return v.getTime();
            const s = String(v || '').trim();
            const d1 = new Date(s);
            return isNaN(d1.getTime()) ? Number.POSITIVE_INFINITY : d1.getTime();
          };
          out = out.slice().sort((a,b) => {
            if (k === 'Last_Used') {
              const at = toTime(a[k]);
              const bt = toTime(b[k]);
              return (at - bt) * d;
            }
            const av = (a[k] ?? '').toString().toLowerCase();
            const bv = (b[k] ?? '').toString().toLowerCase();
            return av < bv ? -1 * d : av > bv ? 1 * d : 0;
          });
        }

        this.filtered = out;
        if (resetSelection || !this.selected || !out.includes(this.selected)) this.selected = out[0] || null;
      },

      format(v) {
        if (typeof v === 'string' && /^\d{4}-\d{2}-\d{2}T/.test(v)) {
          const d = new Date(v);
          return d.toLocaleDateString();
        }
        return v ?? '';
      },

      friendlyMediaName(file) {
        const raw = String(file?.name || '').trim();
        if (!raw) return 'File';
        const withoutSong = this.stripSongTitle(raw);
        const base = this.removeExtension(withoutSong);
        const trimmed = this.trimDelimiters(base);
        if (!trimmed) return raw;
        if (this.isAudioFile(file)) return this.audioLabelFrom(trimmed);
        const doc = this.docLabelFrom(trimmed);
        if (doc) return doc;
        return this.normalizeResidual(trimmed) || raw;
      },

      stripSongTitle(name) {
        const song = String(this.selected?.Song || '').trim();
        if (!song) return name;
        const escaped = song.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const rx = new RegExp(`^${escaped}[\\s._-]*`, 'i');
        return name.replace(rx, '');
      },

      removeExtension(name) {
        return name.replace(/\.[^.]+$/, '');
      },

      trimDelimiters(str) {
        return String(str || '').replace(/^[\s._-]+/, '').replace(/[\s._-]+$/, '');
      },

      normalizeResidual(str) {
        let out = String(str || '');
        out = out.replace(/[_]+/g, ' ');
        out = out.replace(/\s{2,}/g, ' ');
        out = out.replace(/\s*\(/g, ' (').replace(/\s*\)/g, ')');
        return out.trim();
      },

      docLabelFrom(str) {
        for (const rule of docRules) {
          for (const rx of rule.patterns) {
            if (rx.test(str)) {
              const detail = this.normalizeResidual(str.replace(rx, ' '));
              return detail ? `${rule.label} ${detail}` : rule.label;
            }
          }
        }
        return '';
      },

      isAudioFile(file) {
        const mime = String(file?.mimeType || '').toLowerCase();
        if (mime.startsWith('audio/')) return true;
        const name = String(file?.name || '');
        const ext = (name.split('.').pop() || '').toLowerCase();
        return audioExts.has(ext);
      },

      audioLabelFrom(str) {
        const parts = this.extractAudioParts(str);
        if (parts.date && parts.detail) return `${parts.date} - ${parts.detail}`;
        if (parts.date) return parts.date;
        return parts.detail || 'Audio';
      },

      extractAudioParts(str) {
        let working = String(str || '');
        let date = '';
        const paren = /\(([^)]+)\)\s*$/.exec(working);
        if (paren) {
          date = paren[1].trim();
          working = `${working.slice(0, paren.index)}${working.slice(paren.index + paren[0].length)}`;
        }
        if (!date) {
          const compact = /(\d{1,2}[A-Za-z]{3}\d{2,4})/.exec(working);
          if (compact) {
            date = compact[1];
            working = working.replace(compact[0], ' ');
          }
        }
        if (!date) {
          const monthYear = /([A-Za-z]{3,9}\s?\d{2,4})/.exec(working);
          if (monthYear) {
            date = monthYear[1].trim();
            working = working.replace(monthYear[0], ' ');
          }
        }
        const detail = this.normalizeResidual(working);
        return { date: date.trim(), detail };
      },

      async copy(text) { try { await navigator.clipboard.writeText(String(text ?? '')); } catch { } },

      applySuggestion(index, payload) {
        try {
          const name = (payload && payload.name) ? String(payload.name) : String(this.selected?.Song || '');
          const ev = new CustomEvent('use-song', { detail: { index, name }, bubbles: true });
          this.$el.dispatchEvent(ev);
        } catch (_) { }
      },

      fileIcon(mimeType) {
        const type = String(mimeType || '').toLowerCase();
        if (!type) return '\uD83D\uDCC4'; // page facing up
        if (type.startsWith('audio/')) return '\uD83C\uDFB5'; // musical note
        if (type.startsWith('video/')) return '\uD83C\uDFA5'; // movie camera
        if (type.includes('pdf')) return '\uD83D\uDCC4';
        if (type.includes('presentation')) return '\uD83D\uDCCB'; // clipboard
        if (type.includes('spreadsheet') || type.includes('excel')) return '\uD83D\uDCC8'; // chart with upwards trend
        if (type.includes('word') || type.includes('document')) return '\uD83D\uDCC3'; // page with curl
        return '\uD83D\uDCC4';
      },

      searchTokens() {
        return Array.from(
          new Set(
            String(this.q || '')
              .split(/[,\s]+/)
              .map(t => t.trim())
              .filter(Boolean)
              .map(t => t.toLowerCase())
          )
        );
      },

      escapeHtml(str) {
        return String(str || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      },

      highlightedLyrics() {
        const base = this.selected?.Lyrics || this.selected?.['Lyrics (PD)'] || '';
        if (!base) return this.escapeHtml('(No lyrics)');
        const tokens = this.searchTokens();
        let html = this.escapeHtml(base);
        if (tokens.length) {
          const parts = tokens
            .map(tok => tok.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
            .filter(Boolean);
          if (parts.length) {
            const rx = new RegExp(`(${parts.join('|')})`, 'gi');
            html = html.replace(rx, '<mark>$1</mark>');
          }
        }
        return html;
      },

      findSongByName(name) {
        const needle = String(name || '').trim().toLowerCase();
        if (!needle) return null;
        return (this.rows || []).find(r => String(r?.Song || '').trim().toLowerCase() === needle) || null;
      },

      openSongEditor(mode = 'create') {
        console.log(mode);
        if (this.isGuest) {
          this.error = 'View only mode. Sign in to edit songs.';
          return;
        }
        const nextMode = mode === 'edit' ? 'edit' : 'create';
        if (nextMode === 'edit' && !this.selected) {
          this.error = 'Select a song to edit first.';
          return;
        }
        this.songEditorMode = nextMode;
        this.songEditorError = '';
        this.songForm = nextMode === 'edit' ? makeSongForm(this.selected || {}) : makeSongForm();
        this.editorOriginalName = nextMode === 'edit' ? String(this.selected?.Song || '') : '';
        this.showSongEditor = true;
        this.$nextTick(() => {
          try { this.$refs?.songTitle?.focus(); } catch (_) {}
        });
      },

      cancelSongEditor() {
        if (this.songEditorSaving) return;
        this.showSongEditor = false;
        this.songEditorError = '';
      },

      buildSongPayload() {
        const form = this.songForm || {};
        return {
          Song: String(form.Song || '').trim(),
          Leader: String(form.Leader || '').trim(),
          Season: String(form.Season || '').trim(),
          Usage: String(form.Usage || '').trim(),
          Themes: String(form.Themes || '').trim(),
          Keywords: String(form.Keywords || '').trim(),
          Scriptures: String(form.Scriptures || '').trim(),
          Notes: String(form.Notes || '').trim(),
          Lyrics: String(form.Lyrics || ''),
          Link: String(form.Link || '').trim(),
          Sp: form.Sp ? 'Y' : '',
          Archive: form.Archive ? 'Y' : ''
        };
      },

      async saveSongEditor() {
        if (this.isGuest) {
          this.songEditorError = 'View only mode. Sign in to edit songs.';
          return;
        }
        if (this.songEditorSaving) return;
        const payload = this.buildSongPayload();
        if (!payload.Song) {
          this.songEditorError = 'Song title is required.';
          return;
        }
        this.songEditorSaving = true;
        this.songEditorError = '';
        try {
          const res = await callRpc('saveSongEntry', {
            originalName: this.songEditorMode === 'edit' ? this.editorOriginalName : '',
            data: payload
          });
          if (Array.isArray(res?.items)) {
            this.rows = res.items;
            this.buildFilters();
            this.render(true);
            const match = this.findSongByName(payload.Song);
            if (match) await this.select(match);
          }
          this.showSongEditor = false;
        } catch (e) {
          console.error(e);
          this.songEditorError = (e && e.message) ? e.message : 'Unable to save song.';
        } finally {
          this.songEditorSaving = false;
        }
      },

      applyDefaults(payload = {}) {
        const data = (payload && typeof payload === 'object') ? payload : {};
        const has = (k) => Object.prototype.hasOwnProperty.call(data, k);
        const normalize = (v) => typeof v === 'string' ? v : '';
        const ensureOption = (list, value) => {
          if (!value) return Array.isArray(list) ? list : [];
          const arr = Array.isArray(list) ? list.slice() : [];
          if (!arr.includes(value)) arr.unshift(value);
          return arr;
        };

        let shouldRender = false;

        if (has('allowChristmas')) {
          const flag = !!data.allowChristmas;
          if (!this.opts || this.opts.allowChristmas !== flag) {
            this.opts = Object.assign({}, this.opts || {}, { allowChristmas: flag });
            shouldRender = true;
          }
        } else if (data.options && typeof data.options === 'object') {
          this.opts = Object.assign({}, this.opts || {}, data.options);
          shouldRender = true;
        }

        if (has('seed')) {
          const next = normalize(data.seed);
          if (this.q !== next) this.q = next;
        }

        if (has('leader')) {
          const leader = normalize(data.leader);
          this.leaderOptions = ensureOption(this.leaderOptions, leader);
          if (this.selectedLeader !== leader) this.selectedLeader = leader;
        }

        if (has('usage')) {
          const usage = normalize(data.usage);
          this.usageOptions = ensureOption(this.usageOptions, usage);
          if (this.selectedUsage !== usage) this.selectedUsage = usage;
        }

        if (shouldRender) this.render(true);
      },

      syncDefaults(force = false) {
        try {
          if (!window.Alpine || typeof window.Alpine.store !== 'function') return;
          const store = window.Alpine.store('suggestDefaults');
          if (!store) return;
          const ts = Number(store.updatedAt || 0);
          if (!force && ts === this._defaultsTs) return;
          this._defaultsTs = ts;
          this.applyDefaults({
            seed: store.seed ?? '',
            leader: store.leader ?? '',
            usage: store.usage ?? '',
            allowChristmas: store.allowChristmas
          });
        } catch (_) {}
      }
    }
  }
</script>
