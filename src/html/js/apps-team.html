<script>
  const TEAM_ROLE_PRESETS = {
    Worship: ['Leader', 'Guitar', 'Bass', 'Other', 'Keyboard', 'Drums', 'Vocal', 'Projection', 'Sound', 'Communion', 'Offering'],
    Kids: ['Preschool Teacher', 'Toddler Teacher', 'Preschool Helper', 'Toddler Helper', 'Kids Teacher', 'Kids Helper'],
    Hospitality: ['Greeter', 'Security']
  };
  const TEAM_TYPE_PRIORITY = ['Worship'];
  const WEEKLY_COLUMN_LABELS = ['1st Sunday', '2nd Sunday', '3rd Sunday', '4th Sunday', '5th Sunday'];

  function teamApp() {
    return {
      activeTab: 'schedule',
      loading: true,
      error: '',
      roles: [],
      teamOptions: [],
      permissionsOptions: ['subscriber', 'editor', 'administrator'],
      search: '',
      teamFilter: '',
      selectedEmail: '',
      editTeam: '',
      rolePresets: TEAM_ROLE_PRESETS,
      roleSelections: {},
      teamSelections: {},
      editPermissions: '',
      spanishChecked: false,
      saving: false,
      savedAt: 0,
      presetLookup: {},
      showNewMemberModal: false,
      newMemberSaving: false,
      newMemberError: '',
      newMember: {
        email: '',
        first: '',
        last: '',
        permissions: 'subscriber'
      },
      weeklyTeamsLoading: false,
      weeklyTeamsError: '',
      weeklyTeams: [],
      weeklyTeamFilter: '',
      selectedWeeklyTeamId: '',
      weeklyTeamDraft: {
        team: '',
        teamName: '',
        description: ''
      },
      weeklyTeamRolesDraft: [],
      weeklyTeamRoleIdCounter: 0,
      weeklyTeamShowAllRoles: false,
      weeklyTeamSaving: false,
      weeklyTeamSaveError: '',
      weeklyTeamSavedAt: 0,
      weeklyTeamBaseline: null,
      showNewWeeklyTeamModal: false,
      newWeeklyTeamSaving: false,
      newWeeklyTeamError: '',
      newWeeklyTeam: {
        team: '',
        teamName: '',
        description: ''
      },
        memberLookup: {},
        weeklyTeamDefaults: {},
        weeklyTeamLayouts: [],
      weeklyTeamDirtyFlags: {},
      teamDirtyVersions: {},
      teamSaveTimers: {},
      savingTeams: {},
        weeklyTeamsSaving: false,
        weeklyTeamsSaveError: '',
        weeklyTeamsSaveMessage: '',
        weeklyTeamEditorOpen: false,
        showRoleDefaultsModal: false,
        roleDefaultsTeamType: '',
        roleDefaultsDraft: [],
        roleDefaultsSaving: false,
        roleDefaultsError: '',
        scheduleLoading: false,
        scheduleError: '',
        scheduleServices: [],
        scheduleServiceLookup: {},
        scheduleUnavailableMap: {},
        scheduleAssignmentBaseline: {},
        scheduleAssignmentMap: {},
        scheduleTemplateOverrides: {},
        scheduleLayouts: [],
        scheduleDirtyKeys: {},
        scheduleDirty: false,
        scheduleSaving: false,
        scheduleSaveMessage: '',
        scheduleSaveError: '',
        scheduleServiceLimit: 6,

      init() {
        this.computePresetLookup();
        this.resetNewWeeklyTeamForm();
        this.refresh();
      },

      computePresetLookup() {
        const map = {};
        Object.values(this.rolePresets).forEach(list => {
          list.forEach(role => {
            map[this.normalize(role)] = role;
          });
        });
        this.presetLookup = map;
      },

      normalize(value) {
        return String(value || '').trim().toLowerCase();
      },

      canonicalRoleKey(value) {
        let base = this.normalize(value);
        if (!base) return '';
        base = base.replace(/\s*(\d+)$/, '').trim();
        base = base.replace(/\s+(sp|special)$/i, '').trim();
        return base;
      },

      splitList(value) {
        return String(value || '')
          .split(/[,;|]/)
          .map(s => s.trim())
          .filter(Boolean);
      },

      normalizeList(value) {
        const arr = this.splitList(value);
        arr.sort((a, b) => a.localeCompare(b));
        return arr.join('||');
      },

      teamKey(value) {
        return this.normalize(value);
      },

      teamList() {
        const lookup = new Map();
        const add = (value) => {
          const key = this.teamKey(value);
          if (!key) return;
          if (!lookup.has(key)) {
            lookup.set(key, String(value || '').trim());
          }
        };
        (Array.isArray(this.teamOptions) ? this.teamOptions : []).forEach(add);
        Object.keys(this.rolePresets || {}).forEach(add);
        (Array.isArray(this.roles) ? this.roles : []).forEach(row => {
          this.splitList(row?.teamRaw || '').forEach(add);
        });
        return Array.from(lookup.values()).sort((a, b) => a.localeCompare(b));
      },

      buildRoleString() {
        const pick = [];
        Object.entries(this.roleSelections || {}).forEach(([role, checked]) => {
          if (checked) pick.push(role);
        });
        
        const map = new Map();
        [...pick].forEach(role => {
          if (!role) return;
          map.set(role.toLowerCase(), role.trim());
        });
        const result = Array.from(map.values()).sort((a, b) => a.localeCompare(b));
        return result.join(', ');
      },

      buildTeamString() {
        return this.selectedTeams().join(', ');
      },

      get selected() {
        return this.roles.find(r => r.email === this.selectedEmail) || null;
      },

      get dirty() {
        const sel = this.selected;
        if (!sel) return false;
        const rolesChanged = this.normalizeList(sel.role || '') !== this.normalizeList(this.buildRoleString());
        const teamsChanged = this.normalizeList(sel.teamRaw || '') !== this.normalizeList(this.buildTeamString());
        const permsChanged = (sel.permissions || '').trim() !== this.editPermissions.trim();
        const spanishChanged = (String(sel.spanish || '').trim().toUpperCase() === 'Y') !== this.spanishChecked;
        return rolesChanged || teamsChanged || permsChanged || spanishChanged;
      },

      filteredRoles() {
        const q = this.search.trim().toLowerCase();
        const team = this.teamFilter.trim().toLowerCase();
        return this.roles.filter(r => {
          const matchesTeam = !team || r.teams.some(t => t.toLowerCase() === team);
          if (!matchesTeam) return false;
          if (!q) return true;
          const haystack = [
            r.first,
            r.last,
            r.email,
            r.role,
            r.teamRaw,
            r.permissions
          ]
            .join(' ')
            .toLowerCase();
          return haystack.includes(q);
        });
      },

      async refresh() {
        await this.loadRoles();
        await this.loadWeeklyTeams();
        await this.loadSchedule();
      },

      ensurePermissionOption(value) {
        const val = String(value || '').trim();
        if (!val) return;
        const exists = this.permissionsOptions.some(opt => opt.toLowerCase() === val.toLowerCase());
        if (!exists) {
          this.permissionsOptions = [...this.permissionsOptions, val].sort((a, b) => a.localeCompare(b));
        }
      },

      async loadRoles() {
        this.loading = true;
        this.error = '';
        try {
          const res = await callRpc('listRoles', null);
          this.roles = Array.isArray(res?.items) ? res.items : [];
          this.teamOptions = Array.isArray(res?.teams) ? res.teams : [];
          this.memberLookup = this.buildMemberLookup(this.roles);

          const permMap = new Map();
          ['subscriber', 'editor', 'administrator'].forEach(p => permMap.set(p.toLowerCase(), p));
          this.roles.forEach(r => {
            const val = String(r.permissions || '').trim();
            if (val) permMap.set(val.toLowerCase(), val);
          });
          this.permissionsOptions = Array.from(permMap.values()).sort((a, b) => a.localeCompare(b));

          if (this.selectedEmail) {
            this.select(this.selectedEmail);
          }
        } catch (e) {
          console.error(e);
          this.error = (e && e.message) ? e.message : 'Failed to load team.';
        } finally {
          this.loading = false;
        }
      },

      buildMemberLookup(rows) {
        const map = {};
        (Array.isArray(rows) ? rows : []).forEach(row => {
          const email = String(row?.email || '').trim();
          if (!email) return;
          const first = String(row?.first || '').trim();
          const last = String(row?.last || '').trim();
          const label = [first, last].filter(Boolean).join(' ') || email;
          const roles = this.parseRoleList(row?.role);
          map[email.toLowerCase()] = {
            email,
            first,
            last,
            label: `${label} (${email})`.trim(),
            shortLabel: first || label.split(' ')[0] || email,
            roles,
            rolesNormalized: roles.map(r => this.normalize(r)),
            roleCanonicalKeys: roles.map(r => this.canonicalRoleKey(r)).filter(Boolean)
          };
        });
        return map;
      },

      async loadWeeklyTeams() {
        this.weeklyTeamsLoading = true;
        this.weeklyTeamsError = '';
        try {
          const res = await callRpc('listWeeklyTeams', null);
          const items = Array.isArray(res?.items) ? res.items : [];
          this.weeklyTeamDefaults = this.normalizeWeeklyTeamDefaults(res?.defaults);
          this.weeklyTeams = items.map(item => this.normalizeWeeklyTeam(item));
          if (this.selectedWeeklyTeamId) {
            this.selectWeeklyTeam(this.selectedWeeklyTeamId);
          }
          await this.ensureDefaultWeeklyTeams();
          this.weeklyTeamDirtyFlags = {};
          this.weeklyTeamsSaveError = '';
          if (!this.weeklyTeamsSaving) {
            this.weeklyTeamsSaveMessage = '';
          }
          this.rebuildWeeklyTeamLayouts();
        } catch (e) {
          console.error(e);
          this.weeklyTeamsError = (e && e.message) ? e.message : 'Weekly teams are not available yet.';
        } finally {
          this.weeklyTeamsLoading = false;
        }
      },

      async loadSchedule() {
        this.scheduleLoading = true;
        this.scheduleError = '';
        try {
          const payload = { limit: this.scheduleServiceLimit };
          const res = await callRpc('getTeamScheduleSnapshot', payload);
          const services = this.normalizeScheduleServices(res?.services);
          this.scheduleServices = services;
          this.buildScheduleServiceLookup(services);
          this.scheduleUnavailableMap = this.normalizeScheduleUnavailable(res?.unavailable);
          this.scheduleTemplateOverrides = this.buildScheduleTemplateOverrides(res?.assignments);
          const baseline = this.normalizeScheduleAssignments(res?.assignments);
          this.scheduleAssignmentBaseline = baseline;
          this.scheduleAssignmentMap = { ...baseline };
          this.recomputeScheduleDirty();
          this.buildScheduleLayouts();
          if (!this.scheduleDirty) {
            this.scheduleSaveMessage = '';
          }
          this.scheduleSaveError = '';
        } catch (e) {
          console.error(e);
          this.scheduleError = (e && e.message) ? e.message : 'Failed to load schedule.';
        } finally {
          this.scheduleLoading = false;
        }
      },

      normalizeScheduleServices(raw) {
        const list = Array.isArray(raw) ? raw : [];
        const services = [];
        list.forEach(item => {
          const id = String(item?.id || '').trim();
          if (!id) return;
          const date = String(item?.date || '').trim();
          const weekday = String(item?.weekday || '') || this.formatScheduleDate(date, { weekday: 'long' }) || '';
          services.push({
            id,
            date,
            time: String(item?.time || '').trim(),
            type: String(item?.type || '').trim(),
            label: String(item?.label || '') || this.formatScheduleDate(date, { weekday: 'short', month: 'short', day: 'numeric' }) || date,
            shortLabel: String(item?.shortLabel || '') || this.formatScheduleDate(date, { month: 'short', day: 'numeric' }) || date,
            ordinalLabel: String(item?.ordinalLabel || '') || this.computeOrdinalLabel(date, weekday),
            weekday
          });
        });
        return services;
      },

      buildScheduleServiceLookup(services) {
        const lookup = {};
        (Array.isArray(services) ? services : []).forEach(service => {
          if (service?.id) lookup[service.id] = service;
        });
        this.scheduleServiceLookup = lookup;
      },

      normalizeScheduleUnavailable(raw) {
        const map = {};
        if (!raw || typeof raw !== 'object') return map;
        Object.entries(raw).forEach(([serviceId, list]) => {
          const id = String(serviceId || '').trim();
          if (!id) return;
          const set = new Set();
          (Array.isArray(list) ? list : []).forEach(email => {
            const key = String(email || '').trim().toLowerCase();
            if (key) set.add(key);
          });
          map[id] = set;
        });
        return map;
      },

      buildScheduleTemplateOverrides(assignments) {
        const overrides = {};
        (Array.isArray(assignments) ? assignments : []).forEach(entry => {
          const serviceId = String(entry?.serviceId || '').trim();
          const teamKey = this.normalize(entry?.teamType);
          const weeklyTeamName = String(entry?.weeklyTeamName || '').trim();
          if (!serviceId || !teamKey || !weeklyTeamName) return;
          if (!overrides[serviceId]) overrides[serviceId] = {};
          overrides[serviceId][teamKey] = weeklyTeamName;
        });
        return overrides;
      },

      normalizeScheduleAssignments(assignments) {
        const map = {};
        (Array.isArray(assignments) ? assignments : []).forEach(entry => {
          const serviceId = String(entry?.serviceId || '').trim();
          const teamType = String(entry?.teamType || '').trim();
          const roleName = String(entry?.roleName || '').trim();
          if (!serviceId || !teamType || !roleName) return;
          const key = this.scheduleCellKey(serviceId, teamType, roleName);
          map[key] = {
            serviceId,
            teamType,
            roleName,
            weeklyTeamName: String(entry?.weeklyTeamName || '').trim(),
            memberEmail: String(entry?.memberEmail || '').trim(),
            memberName: String(entry?.memberName || '').trim(),
            roleType: String(entry?.roleType || '').trim()
          };
        });
        return map;
      },

      scheduleCellKey(serviceId, teamType, roleName) {
        return [
          String(serviceId || '').trim().toLowerCase(),
          this.normalize(teamType),
          this.normalize(roleName)
        ].join('::');
      },

      resolveScheduleService(serviceOrId) {
        if (!serviceOrId) return null;
        if (typeof serviceOrId === 'object') return serviceOrId;
        const key = String(serviceOrId || '').trim();
        if (!key) return null;
        return this.scheduleServiceLookup?.[key] || null;
      },

      scheduleWeeklyTeamNameForService(teamType, serviceOrId) {
        const service = this.resolveScheduleService(serviceOrId);
        if (!service) return '';
        const serviceOverrides = this.scheduleTemplateOverrides?.[service.id];
        const teamKey = this.normalize(teamType);
        if (serviceOverrides && serviceOverrides[teamKey]) {
          return serviceOverrides[teamKey];
        }
        return service.ordinalLabel || this.computeOrdinalLabel(service.date, service.weekday);
      },

      resolveWeeklyTeamForService(teamType, serviceOrId) {
        const service = this.resolveScheduleService(serviceOrId);
        if (!service) return null;
        const preferredName = this.scheduleWeeklyTeamNameForService(teamType, service);
        if (preferredName) {
          const match = this.findWeeklyTeamByName(teamType, preferredName);
          if (match) return match;
        }
        if (service.ordinalLabel) {
          const match = this.findWeeklyTeamByName(teamType, service.ordinalLabel);
          if (match) return match;
        }
        const teams = this.weeklyTeamsByType(teamType);
        return teams.length ? teams[0] : null;
      },

      lookupWeeklyTemplateAssignment(teamType, serviceOrId, roleLabel) {
        const weeklyTeam = this.resolveWeeklyTeamForService(teamType, serviceOrId);
        if (!weeklyTeam) return null;
        const normalizedRole = this.normalize(roleLabel);
        const roles = Array.isArray(weeklyTeam.roles) ? weeklyTeam.roles : [];
        const match = roles.find(role =>
          this.normalize(role?.roleName || role?.roleType) === normalizedRole
        );
        if (!match) {
          return {
            weeklyTeamName: weeklyTeam.teamName || '',
            roleType: roleLabel,
            memberEmail: '',
            memberName: ''
          };
        }
        return {
          weeklyTeamName: weeklyTeam.teamName || '',
          roleType: match.roleType || match.roleName || roleLabel,
          memberEmail: String(match.memberEmail || '').trim(),
          memberName: String(match.memberName || '').trim()
        };
      },

      isMemberUnavailable(email, serviceId) {
        const serviceKey = String(serviceId || '').trim();
        if (!serviceKey) return false;
        const blocked = this.scheduleUnavailableMap?.[serviceKey];
        if (!blocked || !blocked.size) return false;
        const key = String(email || '').trim().toLowerCase();
        if (!key) return false;
        return blocked.has(key);
      },

      effectiveScheduleAssignment(serviceId, teamType, roleName) {
        const key = this.scheduleCellKey(serviceId, teamType, roleName);
        const explicit = this.scheduleAssignmentMap?.[key];
        const service = this.resolveScheduleService(serviceId);
        const fallbackTeamName = this.scheduleWeeklyTeamNameForService(teamType, service);
        if (explicit) {
          const memberEmail = String(explicit.memberEmail || '').trim();
          const unavailable = memberEmail && this.isMemberUnavailable(memberEmail, serviceId);
          if (unavailable) {
            return {
              serviceId,
              teamType,
              roleName,
              memberEmail: '',
              memberName: '',
              weeklyTeamName: fallbackTeamName || explicit.weeklyTeamName || '',
              roleType: explicit.roleType || roleName,
              source: 'saved'
            };
          }
          const memberName = memberEmail ? (explicit.memberName || this.memberNameByEmail(memberEmail) || '') : '';
          return {
            serviceId,
            teamType,
            roleName,
            memberEmail,
            memberName,
            weeklyTeamName: fallbackTeamName || explicit.weeklyTeamName || '',
            roleType: explicit.roleType || roleName,
            source: 'saved'
          };
        }
        const template = this.lookupWeeklyTemplateAssignment(teamType, service, roleName);
        if (template && template.memberEmail && this.isMemberUnavailable(template.memberEmail, serviceId)) {
          template.memberEmail = '';
          template.memberName = '';
        }
        return {
          serviceId,
          teamType,
          roleName,
          memberEmail: template?.memberEmail || '',
          memberName: template?.memberName || '',
          weeklyTeamName: template?.weeklyTeamName || fallbackTeamName || '',
          roleType: template?.roleType || roleName,
          source: template ? 'template' : 'open'
        };
      },

      buildScheduleLayouts() {
        const services = Array.isArray(this.scheduleServices) ? this.scheduleServices : [];
        if (!services.length) {
          this.scheduleLayouts = [];
          return;
        }
        const teamTypes = this.weeklyTeamTypes();
        const layouts = [];
        teamTypes.forEach(teamType => {
          const roles = this.deriveRoleNamesForTeamType(teamType);
          if (!roles.length) return;
          const columns = services.map(service => ({
            id: service.id,
            service,
            teamLabel: this.scheduleWeeklyTeamNameForService(teamType, service)
          }));
          const rows = roles.map(roleName => {
            const cells = {};
            columns.forEach(column => {
              cells[column.id] = this.effectiveScheduleAssignment(column.id, teamType, roleName);
            });
            return {
              key: `${teamType}::${roleName}`,
              label: roleName,
              cells
            };
          });
          layouts.push({ teamType, columns, rows });
        });
        this.scheduleLayouts = layouts;
      },

      recomputeScheduleDirty() {
        const dirty = {};
        const services = Array.isArray(this.scheduleServices) ? this.scheduleServices : [];
        if (!services.length) {
          this.scheduleDirtyKeys = {};
          this.scheduleDirty = false;
          return;
        }
        const teamTypes = this.weeklyTeamTypes();
        teamTypes.forEach(teamType => {
          const roles = this.deriveRoleNamesForTeamType(teamType);
          if (!roles.length) return;
          services.forEach(service => {
            roles.forEach(roleName => {
              const key = this.scheduleCellKey(service.id, teamType, roleName);
              const baseline = this.scheduleAssignmentBaseline?.[key]?.memberEmail || '';
              const current = this.effectiveScheduleAssignment(service.id, teamType, roleName)?.memberEmail || '';
              if (baseline !== current) {
                dirty[key] = true;
              }
            });
          });
        });
        this.scheduleDirtyKeys = dirty;
        this.scheduleDirty = Object.keys(dirty).length > 0;
      },

      setScheduleAssignment(serviceId, teamType, roleName, memberEmail) {
        const key = this.scheduleCellKey(serviceId, teamType, roleName);
        const normalizedEmail = String(memberEmail || '').trim();
        const entry = {
          serviceId,
          teamType: String(teamType || '').trim(),
          roleName,
          weeklyTeamName: this.scheduleWeeklyTeamNameForService(teamType, serviceId),
          memberEmail: normalizedEmail,
          memberName: normalizedEmail ? this.memberNameByEmail(normalizedEmail) : '',
          roleType: roleName
        };
        const next = { ...(this.scheduleAssignmentMap || {}) };
        next[key] = entry;
        this.scheduleAssignmentMap = next;
        this.scheduleSaveMessage = '';
        this.recomputeScheduleDirty();
        this.buildScheduleLayouts();
      },

      formatScheduleDate(dateStr, options) {
        if (!dateStr) return '';
        const date = new Date(`${dateStr}T00:00:00`);
        if (Number.isNaN(date.getTime())) return dateStr;
        try {
          return new Intl.DateTimeFormat('en-US', options).format(date);
        } catch (_) {
          return dateStr;
        }
      },

      computeOrdinalLabel(dateStr, weekdayLabel = '') {
        if (!dateStr) return '';
        const date = new Date(`${dateStr}T00:00:00`);
        if (Number.isNaN(date.getTime())) return '';
        const day = date.getDate();
        const ordinalIndex = Math.floor((day - 1) / 7) + 1;
        const suffix = (() => {
          if (ordinalIndex % 10 === 1 && ordinalIndex % 100 !== 11) return 'st';
          if (ordinalIndex % 10 === 2 && ordinalIndex % 100 !== 12) return 'nd';
          if (ordinalIndex % 10 === 3 && ordinalIndex % 100 !== 13) return 'rd';
          return 'th';
        })();
        let weekday = weekdayLabel;
        if (!weekday) {
          try {
            weekday = new Intl.DateTimeFormat('en-US', { weekday: 'long' }).format(date);
          } catch (_) {
            weekday = '';
          }
        }
        return `${ordinalIndex}${suffix} ${weekday || ''}`.trim();
      },

      async saveSchedule() {
        if (this.scheduleSaving) return;
        const layouts = Array.isArray(this.scheduleLayouts) ? this.scheduleLayouts : [];
        if (!layouts.length) return;
        const assignments = [];
        layouts.forEach(layout => {
          (Array.isArray(layout?.rows) ? layout.rows : []).forEach(row => {
            (Array.isArray(layout?.columns) ? layout.columns : []).forEach(column => {
              const assignment = this.effectiveScheduleAssignment(column.id, layout.teamType, row.label) || {};
              assignments.push({
                serviceId: column.id,
                serviceType: column.service?.type || '',
                teamType: layout.teamType,
                weeklyTeamName: this.scheduleWeeklyTeamNameForService(layout.teamType, column.service),
                roleName: row.label,
                roleType: assignment.roleType || row.label,
                memberEmail: assignment.memberEmail || '',
                memberName: assignment.memberEmail
                  ? (this.memberNameByEmail(assignment.memberEmail) || assignment.memberName || '')
                  : '',
                status: assignment.memberEmail ? 'Assigned' : 'Open'
              });
            });
          });
        });
        this.scheduleSaving = true;
        this.scheduleSaveError = '';
        this.scheduleSaveMessage = '';
        try {
          await callRpc('saveServiceTeamAssignments', { assignments });
          this.scheduleSaveMessage = 'Schedule saved.';
          await this.loadSchedule();
        } catch (e) {
          console.error(e);
          this.scheduleSaveError = (e && e.message) ? e.message : 'Failed to save schedule.';
        } finally {
          this.scheduleSaving = false;
        }
      },

      normalizeWeeklyTeam(raw) {
        const team = String(raw?.team || '').trim() || '';
        const teamName = String(raw?.teamName || '').trim();
        const description = String(raw?.description || '').trim();
        const roles = Array.isArray(raw?.roles)
          ? raw.roles
              .map(role => ({
                roleName: String(role?.roleName || role?.role || '').trim(),
                roleType: String(role?.roleType || '').trim(),
                memberEmail: String(role?.memberEmail || '').trim(),
                memberName: String(role?.memberName || '').trim()
              }))
              .filter(role => role.roleName)
          : [];
        return {
          id: this.makeWeeklyTeamId(team, teamName),
          team,
          teamName,
          description,
          roles
        };
      },

      normalizeWeeklyTeamDefaults(raw) {
        const result = {};
        if (!raw || typeof raw !== 'object') return result;
        Object.entries(raw).forEach(([teamType, list]) => {
          const entries = Array.isArray(list) ? list : [];
          const normalized = entries
            .map(entry => ({
              roleName: String(entry?.roleName || entry?.role || '').trim(),
              order: Number(entry?.order) || 0
            }))
            .filter(entry => entry.roleName);
          normalized.sort((a, b) => a.order - b.order);
          if (normalized.length) {
            result[String(teamType || '').trim()] = normalized;
          }
        });
        return result;
      },

      weeklyTeamsByType(type) {
        const key = this.normalize(type);
        return (Array.isArray(this.weeklyTeams) ? this.weeklyTeams : [])
          .filter(item => this.normalize(item?.team) === key)
          .sort((a, b) => String(a.teamName || '').localeCompare(String(b.teamName || '')));
      },

      findWeeklyTeamByName(teamType, teamName) {
        const typeKey = this.normalize(teamType);
        const nameKey = this.normalize(teamName);
        return (Array.isArray(this.weeklyTeams) ? this.weeklyTeams : []).find(team =>
          this.normalize(team?.team) === typeKey && this.normalize(team?.teamName) === nameKey
        );
      },

      async ensureDefaultWeeklyTeams() {
        // Skip auto-creation to avoid lock contention; rely on existing teams.
        return false;
      },

      rebuildWeeklyTeamLayouts() {
        const layouts = [];
        const types = this.weeklyTeamTypes();
        types.forEach(type => {
          const layout = this.buildWeeklyTeamLayout(type);
          if (layout) layouts.push(layout);
        });
        layouts.sort((a, b) => String(a.teamType || '').localeCompare(String(b.teamType || '')));
        this.weeklyTeamLayouts = layouts;
        this.buildScheduleLayouts();
        this.recomputeScheduleDirty();
      },

      buildWeeklyTeamLayout(teamType) {
        const teams = this.weeklyTeamsByType(teamType);
        if (!teams.length) return null;
        const normalizedByName = new Map();
        teams.forEach(team => {
          const key = this.normalize(team.teamName);
          if (key && !normalizedByName.has(key)) normalizedByName.set(key, team);
        });
        const usedIds = new Set();
        const orderedColumns = WEEKLY_COLUMN_LABELS.map(label => {
          const match = normalizedByName.get(this.normalize(label));
          if (match) {
            usedIds.add(match.id);
            return {
              id: match.id,
              key: match.id,
              teamName: match.teamName || label,
              description: match.description || '',
              team: match.team || '',
              dirty: this.isWeeklyTeamDirty(match.id),
              roles: match.roles || []
            };
          }
          return {
            id: null,
            key: `placeholder:${teamType}:${label}`,
            teamName: label,
            description: '',
            team: teamType,
            dirty: false,
            roles: [],
            placeholder: true
          };
        });
        const extraColumns = teams
          .filter(team => !usedIds.has(team.id))
          .map(team => ({
            id: team.id,
            key: team.id,
            teamName: team.teamName || '(untitled team)',
            description: team.description || '',
            team: team.team || '',
            dirty: this.isWeeklyTeamDirty(team.id),
            roles: team.roles || []
          }));
        const columns = [...orderedColumns, ...extraColumns];

        const roleNames = [];
        const seen = new Set();
        const addRoleName = (value) => {
          const label = String(value || '').trim();
          if (!label) return;
          const key = this.normalize(label);
          if (seen.has(key)) return;
          seen.add(key);
          roleNames.push(label);
        };

        const defaults = Array.isArray(this.weeklyTeamDefaults?.[teamType])
          ? this.weeklyTeamDefaults[teamType]
          : [];
        defaults.forEach(entry => addRoleName(entry.roleName));

        teams.forEach(team => {
          (Array.isArray(team.roles) ? team.roles : []).forEach(role => {
            addRoleName(role?.roleName || role?.roleType || '(Role)');
          });
        });

        if (!roleNames.length) roleNames.push('Role');

        const roles = roleNames.map(name => {
          const cells = {};
          const normalized = this.normalize(name);
          columns.forEach(column => {
            const assignment = column.id
              ? (Array.isArray(column.roles) ? column.roles : []).find(r =>
                  this.normalize(r?.roleName || r?.roleType) === normalized
                )
              : null;
            const memberEmail = assignment ? String(assignment.memberEmail || '').trim() : '';
            cells[column.key] = {
              memberEmail,
              memberName: memberEmail ? (assignment?.memberName || this.memberNameByEmail(memberEmail) || '') : ''
            };
          });
          return {
            key: `${teamType}::${name}`,
            label: name,
            cells
          };
        });

        return { teamType, teams: columns, roles };
      },

      deriveRoleNamesForTeamType(teamType) {
        const names = [];
        const seen = new Set();
        const pushName = (name) => {
          const clean = String(name || '').trim();
          if (!clean) return;
          const key = this.normalize(clean);
          if (seen.has(key)) return;
          seen.add(key);
          names.push(clean);
        };
        const defaultsMap = this.weeklyTeamDefaults || {};
        let orderedDefaults = Array.isArray(defaultsMap?.[teamType]) ? defaultsMap[teamType] : null;
        if (!orderedDefaults) {
          const normalizedType = this.normalize(teamType);
          const fallbackKey = Object.keys(defaultsMap).find(key => this.normalize(key) === normalizedType);
          orderedDefaults = fallbackKey ? defaultsMap[fallbackKey] : [];
        }
        (orderedDefaults || []).forEach(entry => {
          pushName(entry?.roleName || entry?.roleType);
        });
        this.weeklyTeamsByType(teamType).forEach(team => {
          (Array.isArray(team.roles) ? team.roles : []).forEach(role => {
            pushName(role?.roleName || role?.roleType);
          });
        });
        if (!names.length && Array.isArray(this.rolePresets?.[teamType])) {
          this.rolePresets[teamType].forEach(pushName);
        }
        return names;
      },

      openRoleDefaults(teamType) {
        this.roleDefaultsTeamType = teamType;
        const existing = Array.isArray(this.weeklyTeamDefaults?.[teamType])
          ? this.weeklyTeamDefaults[teamType].map(entry => entry.roleName)
          : [];
        const fallback = existing.length ? existing : this.deriveRoleNamesForTeamType(teamType);
        this.roleDefaultsDraft = (fallback.length ? fallback : ['']).map(name => String(name || ''));
        this.roleDefaultsError = '';
        this.showRoleDefaultsModal = true;
        this.$nextTick(() => {
          try {
            const first = this.$el?.querySelector('[data-role-default-input]');
            if (first) first.focus();
          } catch (_) {}
        });
      },

      closeRoleDefaults() {
        if (this.roleDefaultsSaving) return;
        this.showRoleDefaultsModal = false;
      },

      addRoleDefault() {
        this.roleDefaultsDraft = [...(this.roleDefaultsDraft || []), ''];
        this.$nextTick(() => {
          try {
            const inputs = this.$el?.querySelectorAll('[data-role-default-input]');
            if (inputs && inputs.length) inputs[inputs.length - 1].focus();
          } catch (_) {}
        });
      },

      removeRoleDefault(index) {
        const list = Array.isArray(this.roleDefaultsDraft) ? [...this.roleDefaultsDraft] : [];
        if (list.length <= 1) {
          list[0] = '';
        } else {
          list.splice(index, 1);
        }
        this.roleDefaultsDraft = list;
      },

      moveRoleDefault(index, delta) {
        const list = Array.isArray(this.roleDefaultsDraft) ? [...this.roleDefaultsDraft] : [];
        const target = index + delta;
        if (target < 0 || target >= list.length) return;
        const [item] = list.splice(index, 1);
        list.splice(target, 0, item);
        this.roleDefaultsDraft = list;
      },

      async saveRoleDefaults() {
        if (this.roleDefaultsSaving) return;
        const team = String(this.roleDefaultsTeamType || '').trim();
        if (!team) {
          this.roleDefaultsError = 'Select a team type.';
          return;
        }
        const roles = (Array.isArray(this.roleDefaultsDraft) ? this.roleDefaultsDraft : [])
          .map(role => String(role || '').trim())
          .filter(Boolean);
        if (!roles.length) {
          this.roleDefaultsError = 'Add at least one role name.';
          return;
        }
        this.roleDefaultsSaving = true;
        this.roleDefaultsError = '';
        try {
          const res = await callRpc('saveWeeklyTeamDefaults', { team, roles });
          if (res?.defaults) {
            this.weeklyTeamDefaults = this.normalizeWeeklyTeamDefaults(res.defaults);
          }
          if (Array.isArray(res?.items)) {
            this.weeklyTeams = res.items.map(item => this.normalizeWeeklyTeam(item));
          }
          this.showRoleDefaultsModal = false;
          this.rebuildWeeklyTeamLayouts();
        } catch (e) {
          console.error(e);
          this.roleDefaultsError = (e && e.message) ? e.message : 'Failed to save default roles.';
        } finally {
          this.roleDefaultsSaving = false;
        }
      },

      setWeeklyTeamMember(teamId, roleLabel, email) {
        const team = (Array.isArray(this.weeklyTeams) ? this.weeklyTeams : []).find(item => item.id === teamId);
        if (!team || !teamId) return;
        this.weeklyTeamsSaveMessage = '';
        this.weeklyTeamsSaveError = '';
        const roleName = String(roleLabel || '').trim();
        if (!roleName) return;
        const roles = Array.isArray(team.roles) ? team.roles : [];
        const normalizedRoleName = this.normalize(roleName);
        let entry = roles.find(r => this.normalize(r?.roleName || r?.roleType) === normalizedRoleName);
        if (!entry) {
          entry = {
            roleName,
            roleType: roleName,
            memberEmail: '',
            memberName: ''
          };
          roles.push(entry);
          team.roles = roles;
        }
        entry.roleName = roleName;
        entry.roleType = entry.roleType || roleName;
        const trimmed = String(email || '').trim();
        entry.memberEmail = trimmed;
        entry.memberName = trimmed ? (this.memberNameByEmail(trimmed) || entry.memberName || '') : '';
        if (!trimmed) {
          entry.memberName = '';
        }
        const version = this.markWeeklyTeamDirty(teamId);
        this.rebuildWeeklyTeamLayouts();
        this.queueTeamSave(teamId, version);
      },

      markWeeklyTeamDirty(teamId) {
        if (!teamId) return 0;
        const nextVersion = (this.teamDirtyVersions?.[teamId] || 0) + 1;
        this.teamDirtyVersions = { ...(this.teamDirtyVersions || {}), [teamId]: nextVersion };
        this.weeklyTeamDirtyFlags = {
          ...this.weeklyTeamDirtyFlags,
          [teamId]: true
        };
        return nextVersion;
      },

      clearWeeklyTeamDirtyFlag(teamId) {
        if (!teamId) return;
        const next = { ...this.weeklyTeamDirtyFlags };
        delete next[teamId];
        this.weeklyTeamDirtyFlags = next;
        const versions = { ...(this.teamDirtyVersions || {}) };
        delete versions[teamId];
        this.teamDirtyVersions = versions;
        if (this.teamSaveTimers?.[teamId]) {
          clearTimeout(this.teamSaveTimers[teamId]);
          const timers = { ...(this.teamSaveTimers || {}) };
          delete timers[teamId];
          this.teamSaveTimers = timers;
        }
      },

      isWeeklyTeamDirty(teamId) {
        return Boolean(teamId && this.weeklyTeamDirtyFlags && this.weeklyTeamDirtyFlags[teamId]);
      },

      hasDirtyWeeklyTeams() {
        return Object.values(this.weeklyTeamDirtyFlags || {}).some(Boolean);
      },

      groupDirtyIds(group) {
        if (!group || !Array.isArray(group.teams)) return [];
        return group.teams
          .map(team => team && team.id)
          .filter(id => this.isWeeklyTeamDirty(id));
      },

      queueTeamSave(teamId, version) {
        if (!teamId) return;
        if (this.teamSaveTimers?.[teamId]) {
          clearTimeout(this.teamSaveTimers[teamId]);
        }
        const timers = { ...(this.teamSaveTimers || {}) };
        timers[teamId] = setTimeout(() => {
          const currentTimers = { ...(this.teamSaveTimers || {}) };
          delete currentTimers[teamId];
          this.teamSaveTimers = currentTimers;
          this.saveDirtyWeeklyTeams([teamId], { [teamId]: version }).catch(err => console.error(err));
        }, 400);
        this.teamSaveTimers = timers;
      },

      async saveDirtyWeeklyTeams(targetIds = null, expectedVersions = null) {
        const targeted = Array.isArray(targetIds) && targetIds.length;
        const idsToSave = targeted
          ? targetIds.filter(Boolean)
          : Object.entries(this.weeklyTeamDirtyFlags || {})
              .filter(([, flag]) => flag)
              .map(([id]) => id);
        if (!idsToSave.length) return;
        if (!targeted && this.weeklyTeamsSaving) return;
        if (!targeted && !this.hasDirtyWeeklyTeams()) return;
        if (!targeted) this.weeklyTeamsSaving = true;
        this.weeklyTeamsSaveError = '';
        if (!targeted) this.weeklyTeamsSaveMessage = '';
        try {
          for (const id of idsToSave) {
            if (!id) continue;
            if (targeted && this.savingTeams?.[id]) continue;
            if (targeted) {
              this.savingTeams = { ...(this.savingTeams || {}), [id]: true };
            }
            const team = (Array.isArray(this.weeklyTeams) ? this.weeklyTeams : []).find(item => item.id === id);
            if (!team) {
              if (targeted) {
                const next = { ...(this.savingTeams || {}) };
                delete next[id];
                this.savingTeams = next;
              }
              continue;
            }
            const payload = {
              team: team.team,
              teamName: team.teamName,
              description: team.description,
              roles: (Array.isArray(team.roles) ? team.roles : []).map(role => ({
                roleName: String(role?.roleName || '').trim(),
                roleType: String(role?.roleType || '').trim(),
                memberEmail: String(role?.memberEmail || '').trim(),
                memberName: String(role?.memberName || '').trim()
              }))
            };
            const expected = targeted ? (expectedVersions?.[id] ?? this.teamDirtyVersions?.[id] ?? null) : null;
            try {
              const res = await callRpc('saveWeeklyTeam', payload);
              if (!targeted && res?.items) {
                this.weeklyTeams = res.items.map(item => this.normalizeWeeklyTeam(item));
                if (res?.defaults) {
                  this.weeklyTeamDefaults = this.normalizeWeeklyTeamDefaults(res.defaults);
                }
              }
              if (!expected || this.teamDirtyVersions?.[id] === expected) {
                this.clearWeeklyTeamDirtyFlag(id);
              }
            } catch (err) {
              const message = (err && err.message) ? err.message : String(err || '');
              if (targeted && /lock/i.test(message)) {
                if (this.teamSaveTimers?.[id]) {
                  clearTimeout(this.teamSaveTimers[id]);
                }
                const timers = { ...(this.teamSaveTimers || {}) };
                timers[id] = setTimeout(() => {
                  const currentVersion = this.teamDirtyVersions?.[id] || expected || 0;
                  this.saveDirtyWeeklyTeams([id], { [id]: currentVersion }).catch(() => {});
                }, 600);
                this.teamSaveTimers = timers;
                const next = { ...(this.savingTeams || {}) };
                delete next[id];
                this.savingTeams = next;
                continue;
              }
              throw err;
            }
            if (targeted) {
              const next = { ...(this.savingTeams || {}) };
              delete next[id];
              this.savingTeams = next;
              const currentVersion = this.teamDirtyVersions?.[id];
              if (this.weeklyTeamDirtyFlags?.[id] && currentVersion && (!expected || currentVersion > expected)) {
                this.saveDirtyWeeklyTeams([id], { [id]: currentVersion }).catch(() => {});
              }
            }
          }
          if (!targeted) {
            await this.loadWeeklyTeams();
            this.weeklyTeamsSaveMessage = idsToSave.length === 1 ? 'Weekly team saved.' : 'Weekly teams saved.';
          } else {
            this.rebuildWeeklyTeamLayouts();
          }
        } catch (e) {
          console.error(e);
          this.weeklyTeamsSaveError = (e && e.message) ? e.message : 'Failed to save weekly teams.';
        } finally {
          if (!targeted) {
            this.weeklyTeamsSaving = false;
            this.rebuildWeeklyTeamLayouts();
          }
        }
      },

      openWeeklyTeamEditor(id) {
        this.selectWeeklyTeam(id);
        if (this.selectedWeeklyTeamId) {
          this.weeklyTeamEditorOpen = true;
        }
      },

      closeWeeklyTeamEditor() {
        if (this.weeklyTeamSaving) return;
        this.weeklyTeamEditorOpen = false;
        this.selectedWeeklyTeamId = '';
      },

      makeWeeklyTeamId(team, teamName) {
        const t = String(team || '').trim().toLowerCase();
        const n = String(teamName || '').trim().toLowerCase();
        return `${t}::${n}`;
      },

      weeklyTeamTypes() {
        const lookup = new Map();
        const add = (value) => {
          const val = String(value || '').trim();
          if (!val) return;
          const key = val.toLowerCase();
          if (!lookup.has(key)) {
            lookup.set(key, val);
          }
        };
        Object.keys(this.rolePresets || {}).forEach(add);
        (Array.isArray(this.weeklyTeams) ? this.weeklyTeams : []).forEach(item => add(item.team));
        const priorityIndex = value => {
          const key = String(value || '').trim().toLowerCase();
          const idx = TEAM_TYPE_PRIORITY.findIndex(name => name.toLowerCase() === key);
          return idx >= 0 ? idx : TEAM_TYPE_PRIORITY.length;
        };
        return Array.from(lookup.values()).sort((a, b) => {
          const pa = priorityIndex(a);
          const pb = priorityIndex(b);
          if (pa !== pb) return pa - pb;
          return a.localeCompare(b);
        });
      },

      filteredWeeklyTeams() {
        const filter = String(this.weeklyTeamFilter || '').trim().toLowerCase();
        const list = Array.isArray(this.weeklyTeams) ? this.weeklyTeams : [];
        return list
          .filter(item => !filter || String(item.team || '').trim().toLowerCase() === filter)
          .sort((a, b) => {
            const teamA = String(a.team || '').toLowerCase();
            const teamB = String(b.team || '').toLowerCase();
            if (teamA !== teamB) return teamA.localeCompare(teamB);
            const nameA = String(a.teamName || '');
            const nameB = String(b.teamName || '');
            return nameA.localeCompare(nameB);
          });
      },

      roleTypeOptions() {
        const teamType = String(this.weeklyTeamDraft?.team || '').trim();
        const includeExtra = this.weeklyTeamShowAllRoles;
        const map = new Map();
        const add = (value) => {
          const val = String(value || '').trim();
          if (!val) return;
          const key = val.toLowerCase();
          if (!map.has(key)) {
            map.set(key, val);
          }
        };
        const presetList = Array.isArray(this.rolePresets?.[teamType]) ? this.rolePresets[teamType] : [];
        presetList.forEach(add);
        (Array.isArray(this.weeklyTeamRolesDraft) ? this.weeklyTeamRolesDraft : []).forEach(role => {
          add(role.roleType || role.roleName);
        });
        if (includeExtra) {
          (Array.isArray(this.weeklyTeams) ? this.weeklyTeams : []).forEach(item => {
            if (teamType && String(item.team || '').trim() !== teamType) return;
            (Array.isArray(item.roles) ? item.roles : []).forEach(role => {
              add(role.roleType || role.roleName);
            });
          });
          Object.values(this.memberLookup || {}).forEach(member => {
            (Array.isArray(member.roles) ? member.roles : []).forEach(add);
          });
        }
        return Array.from(map.values()).sort((a, b) => a.localeCompare(b));
      },

      canonicalRoleTypeValue(value, fallback = '') {
        const raw = String(value || '').trim() || String(fallback || '').trim();
        if (!raw) return '';
        const lower = raw.toLowerCase();
        const match = this.roleTypeOptions().find(opt => opt.toLowerCase() === lower);
        return match || raw;
      },

      canonicalMemberEmail(value) {
        const email = String(value || '').trim();
        if (!email) return '';
        const key = email.toLowerCase();
        const info = this.memberLookup?.[key];
        return info?.email || email;
      },

      syncWeeklyRoleSelections() {
        this.$nextTick(() => {
          const rows = Array.isArray(this.weeklyTeamRolesDraft) ? this.weeklyTeamRolesDraft : [];
          rows.forEach(role => {
            if (!role) return;
            const canonicalType = this.canonicalRoleTypeValue(role.roleType, role.roleName);
            if (canonicalType !== undefined) {
              role.roleType = canonicalType;
            }
            const canonicalEmail = this.canonicalMemberEmail(role.memberEmail);
            role.memberEmail = canonicalEmail;
            if (canonicalEmail) {
              role.memberName = this.memberNameByEmail(canonicalEmail) || role.memberName || '';
            }
            const typeEl = this.$el?.querySelector(`[data-role-type-select="${role.id}"]`);
            if (typeEl && typeEl.value !== role.roleType) {
              typeEl.value = role.roleType || '';
            }
            const memberEl = this.$el?.querySelector(`[data-role-member-select="${role.id}"]`);
            if (memberEl && memberEl.value !== role.memberEmail) {
              memberEl.value = role.memberEmail || '';
            }
          });
        });
      },

      roleTypeOptionsForRole(role) {
        const current = role && (role.roleType || role.roleName);
        const opts = this.roleTypeOptions();
        if (current) {
          const val = String(current).trim();
          if (val) {
            const match = opts.find(o => o.toLowerCase() === val.toLowerCase());
            if (match) {
              if (role && role.roleType !== match) {
                role.roleType = match;
              }
            } else {
              opts.push(val);
              opts.sort((a, b) => a.localeCompare(b));
              if (role && role.roleType !== val) {
                role.roleType = val;
              }
            }
          }
        }
        return opts;
      },

      formatWeeklyTeamSummary(team) {
        const roles = Array.isArray(team?.roles) ? team.roles : [];
        if (!roles.length) return 'No roles defined';
        const filled = roles.filter(item => String(item?.memberEmail || '').trim());
        if (!filled.length) return `${roles.length} roles, all unassigned`;
        return `${filled.length} of ${roles.length} roles assigned`;
      },

      nextWeeklyRoleId() {
        this.weeklyTeamRoleIdCounter += 1;
        return `role-${Date.now()}-${this.weeklyTeamRoleIdCounter}`;
      },

      makeWeeklyTeamRoleDraft(role = {}) {
        const roleName = String(role?.roleName || role?.role || '').trim();
        const roleTypeRaw = String(role?.roleType || '').trim();
        const memberEmailRaw = String(role?.memberEmail || '').trim();
        const canonicalEmail = this.canonicalMemberEmail(memberEmailRaw);
        return {
          id: this.nextWeeklyRoleId(),
          roleName,
          roleType: this.canonicalRoleTypeValue(roleTypeRaw, roleName),
          memberEmail: canonicalEmail,
          memberName: this.memberNameByEmail(canonicalEmail) || String(role?.memberName || '').trim()
        };
      },

      cloneWeeklyTeamRoles(list) {
        const arr = [];
        (Array.isArray(list) ? list : []).forEach(role => {
          arr.push(this.makeWeeklyTeamRoleDraft(role));
        });
        return arr;
      },

      addWeeklyTeamRole(roleType = '') {
        const types = this.roleTypeOptions();
        const chosenType = String(roleType || (types.length ? types[0] : '') || '').trim();
        const entry = this.makeWeeklyTeamRoleDraft({
          roleType: chosenType,
          roleName: ''
        });
        this.weeklyTeamRolesDraft = [
          ...(Array.isArray(this.weeklyTeamRolesDraft) ? this.weeklyTeamRolesDraft : []),
          entry
        ];
        this.syncWeeklyRoleSelections();
      },

      removeWeeklyTeamRole(id) {
        const list = Array.isArray(this.weeklyTeamRolesDraft) ? this.weeklyTeamRolesDraft : [];
        this.weeklyTeamRolesDraft = list.filter(role => role.id !== id);
        this.syncWeeklyRoleSelections();
      },

      selectWeeklyTeam(id) {
        const row = (Array.isArray(this.weeklyTeams) ? this.weeklyTeams : []).find(item => item.id === id);
        if (!row) return;
        this.selectedWeeklyTeamId = row.id;
        this.weeklyTeamDraft = {
          team: row.team || '',
          teamName: row.teamName || '',
          description: row.description || ''
        };
        this.weeklyTeamRoleIdCounter = 0;
        this.weeklyTeamRolesDraft = this.cloneWeeklyTeamRoles(row.roles || []);
        this.weeklyTeamShowAllRoles = false;
        this.weeklyTeamSaveError = '';
        this.weeklyTeamSavedAt = 0;
        this.updateWeeklyTeamBaseline();
        this.syncWeeklyRoleSelections();
      },

      updateWeeklyTeamBaseline() {
        this.weeklyTeamBaseline = this.captureWeeklyTeamDraft();
      },

      captureWeeklyTeamDraft() {
        const roles = [];
        (Array.isArray(this.weeklyTeamRolesDraft) ? this.weeklyTeamRolesDraft : []).forEach(role => {
          const roleName = String(role?.roleName || '').trim();
          if (!roleName) return;
          roles.push({
            roleName,
            roleType: String(role?.roleType || '').trim(),
            memberEmail: String(role?.memberEmail || '').trim(),
            memberName: String(role?.memberName || '').trim()
          });
        });
        return {
          team: String(this.weeklyTeamDraft?.team || '').trim(),
          teamName: String(this.weeklyTeamDraft?.teamName || '').trim(),
          description: String(this.weeklyTeamDraft?.description || '').trim(),
          roles
        };
      },

      compareWeeklyTeamDraft(a, b) {
        if (!a || !b) return false;
        const normalize = (data) => {
          const roles = Array.isArray(data.roles) ? data.roles : [];
          return {
            team: String(data.team || '').trim(),
            teamName: String(data.teamName || '').trim(),
            description: String(data.description || '').trim(),
            roles: roles.map(role => ({
              roleName: String(role?.roleName || '').trim(),
              roleType: String(role?.roleType || '').trim(),
              memberEmail: String(role?.memberEmail || '').trim()
            }))
          };
        };
        const left = normalize(a);
        const right = normalize(b);
        if (left.team !== right.team) return false;
        if (left.teamName !== right.teamName) return false;
        if (left.description !== right.description) return false;
        if (left.roles.length !== right.roles.length) return false;
        for (let i = 0; i < left.roles.length; i += 1) {
          const l = left.roles[i];
          const r = right.roles[i];
          if (l.roleName !== r.roleName) return false;
          if (l.roleType !== r.roleType) return false;
          if (l.memberEmail !== r.memberEmail) return false;
        }
        return true;
      },

      resetWeeklyTeamEdits() {
        if (!this.weeklyTeamBaseline) return;
        this.weeklyTeamDraft = {
          team: this.weeklyTeamBaseline.team,
          teamName: this.weeklyTeamBaseline.teamName,
          description: this.weeklyTeamBaseline.description
        };
        this.weeklyTeamRoleIdCounter = 0;
        this.weeklyTeamRolesDraft = this.cloneWeeklyTeamRoles(this.weeklyTeamBaseline.roles || []);
        this.syncWeeklyRoleSelections();
      },

      toggleShowAllRoles() {
        this.weeklyTeamShowAllRoles = !this.weeklyTeamShowAllRoles;
      },

      handleWeeklyTeamTypeChange() {
        // Ensure we keep baseline updated after manual changes.
      },

      parseRoleList(value) {
        return String(value || '')
          .split(/[,;|]/)
          .map(v => v.trim())
          .filter(Boolean);
      },

      memberOptions() {
        const list = Object.values(this.memberLookup || {});
        return list.sort((a, b) => a.label.localeCompare(b.label));
      },

      memberOptionsForRoleType(roleType, role = null, opts = null) {
        const normalizedType = this.normalize(roleType) || this.normalize(role?.roleName);
        const options = this.memberOptions();
        const canonicalType = this.canonicalRoleKey(roleType) || this.canonicalRoleKey(role?.roleName);
        let filtered = normalizedType
          ? options.filter(opt => Array.isArray(opt.rolesNormalized) && opt.rolesNormalized.includes(normalizedType))
          : options;
        if (canonicalType) {
          const canonicalFiltered = options.filter(opt =>
            Array.isArray(opt.roleCanonicalKeys) && opt.roleCanonicalKeys.includes(canonicalType)
          );
          if (canonicalFiltered.length) {
            filtered = canonicalFiltered;
          }
        }
        if (!filtered.length) {
          filtered = options;
        }
        const serviceId = opts && opts.serviceId ? String(opts.serviceId || '').trim() : '';
        let blocked = null;
        if (serviceId) {
          blocked = this.scheduleUnavailableMap?.[serviceId];
          if (blocked && blocked.size) {
            filtered = filtered.filter(opt => !blocked.has(String(opt.email || '').trim().toLowerCase()));
          }
        }
        const assignedEmailRaw = role ? String(role.memberEmail || '').trim() : '';
        if (assignedEmailRaw) {
          const assignedEmail = assignedEmailRaw.toLowerCase();
          const exists = filtered.some(opt => String(opt.email || '').trim().toLowerCase() === assignedEmail);
          const isBlocked = blocked && blocked.has(assignedEmail);
          if (!exists && !isBlocked) {
            const label = role?.memberName || this.memberLabel(assignedEmailRaw) || assignedEmailRaw;
            filtered = [
              { email: assignedEmailRaw, label: `${label} (not in roster)` },
              ...filtered
            ];
          }
        }
        return filtered.map(opt => ({
          ...opt,
          display: opt.shortLabel || opt.label || opt.email
        }));
      },

      memberLabel(email, fallback = '') {
        const key = String(email || '').trim().toLowerCase();
        if (!key) return fallback || '';
        return this.memberLookup?.[key]?.label || fallback || email || '';
      },

      memberNameByEmail(email) {
        const key = String(email || '').trim().toLowerCase();
        if (!key) return '';
        const info = this.memberLookup?.[key];
        const first = String(info?.first || '').trim();
        const last = String(info?.last || '').trim();
        const name = [first, last].filter(Boolean).join(' ');
        return name || info?.label || email || '';
      },

      get selectedWeeklyTeam() {
        return (Array.isArray(this.weeklyTeams) ? this.weeklyTeams : []).find(item => item.id === this.selectedWeeklyTeamId) || null;
      },

      get weeklyTeamDirty() {
        if (!this.selectedWeeklyTeam) return false;
        if (!this.weeklyTeamBaseline) return false;
        const draft = this.captureWeeklyTeamDraft();
        return !this.compareWeeklyTeamDraft(draft, this.weeklyTeamBaseline);
      },

      async saveWeeklyTeam() {
        if (!this.selectedWeeklyTeam || this.weeklyTeamSaving || !this.weeklyTeamDirty) return;
        const draft = this.captureWeeklyTeamDraft();
        if (!Array.isArray(draft.roles) || !draft.roles.length) {
          this.weeklyTeamSaveError = 'Add at least one role name before saving.';
          this.weeklyTeamSavedAt = 0;
          return;
        }
        this.weeklyTeamSaving = true;
        this.weeklyTeamSaveError = '';
        try {
          const payload = {
            team: draft.team,
            teamName: draft.teamName,
            description: draft.description,
            roles: (Array.isArray(draft.roles) ? draft.roles : []).map(role => ({
              roleName: role.roleName,
              roleType: role.roleType,
              memberEmail: role.memberEmail,
              memberName: this.memberNameByEmail(role.memberEmail) || role.memberName
            })),
            original: {
              team: this.weeklyTeamBaseline.team,
              teamName: this.weeklyTeamBaseline.teamName
            }
          };
          const res = await callRpc('saveWeeklyTeam', payload);
          const items = Array.isArray(res?.items) ? res.items : null;
          if (items) {
            this.weeklyTeams = items.map(item => this.normalizeWeeklyTeam(item));
          } else {
            this.upsertWeeklyTeamLocal(draft, this.weeklyTeamBaseline);
          }
          const newId = this.makeWeeklyTeamId(draft.team, draft.teamName);
          this.clearWeeklyTeamDirtyFlag(this.selectedWeeklyTeamId);
          this.clearWeeklyTeamDirtyFlag(newId);
          this.rebuildWeeklyTeamLayouts();
          this.selectWeeklyTeam(newId);
          this.weeklyTeamSavedAt = Date.now();
        } catch (e) {
          console.error(e);
          this.weeklyTeamSaveError = (e && e.message) ? e.message : 'Failed to save weekly team.';
        } finally {
          this.weeklyTeamSaving = false;
        }
      },

      upsertWeeklyTeamLocal(draft, baseline) {
        const list = Array.isArray(this.weeklyTeams) ? [...this.weeklyTeams] : [];
        const next = {
          id: this.makeWeeklyTeamId(draft.team, draft.teamName),
          team: draft.team,
          teamName: draft.teamName,
          description: draft.description,
          roles: []
        };
        (Array.isArray(draft.roles) ? draft.roles : []).forEach(role => {
          const roleName = String(role?.roleName || '').trim();
          if (!roleName) return;
          const memberEmail = String(role?.memberEmail || '').trim();
          next.roles.push({
            roleName,
            roleType: String(role?.roleType || '').trim(),
            memberEmail,
            memberName: role?.memberName || this.memberNameByEmail(memberEmail)
          });
        });
        let index = list.findIndex(item => item.id === next.id);
        if (index === -1 && baseline) {
          const baselineId = this.makeWeeklyTeamId(baseline.team, baseline.teamName);
          index = list.findIndex(item => item.id === baselineId);
        }
        if (index === -1) {
          list.push(next);
        } else {
          list[index] = next;
        }
        this.weeklyTeams = list;
      },

      resetNewWeeklyTeamForm() {
        this.newWeeklyTeamError = '';
        const defaultTeam = this.defaultWeeklyTeamType();
        this.newWeeklyTeam = {
          team: defaultTeam,
          teamName: '',
          description: ''
        };
      },

      defaultWeeklyTeamType() {
        const list = this.weeklyTeamTypes();
        return list.length ? list[0] : '';
      },

      openNewWeeklyTeam(teamType = '') {
        this.resetNewWeeklyTeamForm();
        if (teamType) {
          this.newWeeklyTeam.team = teamType;
        }
        this.showNewWeeklyTeamModal = true;
      },

      closeNewWeeklyTeam() {
        if (this.newWeeklyTeamSaving) return;
        this.showNewWeeklyTeamModal = false;
      },

      async createWeeklyTeam() {
        if (this.newWeeklyTeamSaving) return;
        const team = String(this.newWeeklyTeam.team || '').trim();
        const teamName = String(this.newWeeklyTeam.teamName || '').trim();
        if (!team) { this.newWeeklyTeamError = 'Team type is required.'; return; }
        if (!teamName) { this.newWeeklyTeamError = 'Team name is required.'; return; }
        this.newWeeklyTeamSaving = true;
        this.newWeeklyTeamError = '';
        try {
          const payload = {
            team,
            teamName,
            description: String(this.newWeeklyTeam.description || '').trim()
          };
          const res = await callRpc('createWeeklyTeam', payload);
          const items = Array.isArray(res?.items) ? res.items : null;
          if (items) {
            this.weeklyTeams = items.map(item => this.normalizeWeeklyTeam(item));
          } else {
            this.upsertWeeklyTeamLocal({
              team: payload.team,
              teamName: payload.teamName,
              description: payload.description,
              roles: []
            });
          }
          const newId = this.makeWeeklyTeamId(payload.team, payload.teamName);
          this.showNewWeeklyTeamModal = false;
          this.selectWeeklyTeam(newId);
        } catch (e) {
          console.error(e);
          this.newWeeklyTeamError = (e && e.message) ? e.message : 'Failed to create weekly team.';
        } finally {
          this.newWeeklyTeamSaving = false;
        }
      },

      select(email) {
        const row = this.roles.find(r => r.email === email);
        if (!row) return;
        this.selectedEmail = row.email;
        this.editTeam = row.teamRaw || '';
        const teamSelections = {};
        this.splitList(row.teamRaw || '').forEach(team => {
          if (!team) return;
          const key = this.teamKey(team);
          if (!key) return;
          teamSelections[key] = team.trim();
        });
        this.teamSelections = teamSelections;
        this.editTeam = this.buildTeamString();
        const roleSelections = {};
        const leftovers = [];
        this.splitList(row.role || '').forEach(role => {
          const canonical = this.presetLookup[this.normalize(role)];
          if (canonical) {
            roleSelections[canonical] = true;
          } else {
            leftovers.push(role);
          }
        });
        this.roleSelections = roleSelections;
        
        this.editPermissions = (row.permissions || '').trim();
        this.ensurePermissionOption(this.editPermissions);
        this.spanishChecked = String(row.spanish || '').trim().toUpperCase() === 'Y';
        this.savedAt = 0;
      },

      resetEdits() {
        if (this.selectedEmail) this.select(this.selectedEmail);
      },

      setRole(role, checked) {
        const next = { ...this.roleSelections };
        if (checked) next[role] = true;
        else delete next[role];
        this.roleSelections = next;
      },

      toggleTeam(team, checked) {
        const next = { ...this.teamSelections };
        const key = this.teamKey(team);
        if (!key) return;
        if (checked) next[key] = String(team || '').trim();
        else delete next[key];
        this.teamSelections = next;
        this.editTeam = this.buildTeamString();
      },

      selectedTeams() {
        return Object.values(this.teamSelections || {}).sort((a, b) => a.localeCompare(b));
      },

      isTeamSelected(team) {
        const key = this.teamKey(team);
        if (!key) return false;
        return Boolean(this.teamSelections && this.teamSelections[key]);
      },

      async save() {
        const sel = this.selected;
        if (!sel || this.saving || !this.dirty) return;
        this.saving = true;
        this.error = '';
        try {
          const payload = {
            email: sel.email,
            team: this.buildTeamString(),
            role: this.buildRoleString(),
            permissions: this.editPermissions.trim(),
            spanish: this.spanishChecked ? 'Y' : ''
          };
          const res = await callRpc('updateRoleEntry', payload);
          this.roles = Array.isArray(res?.items) ? res.items : this.roles;
          this.teamOptions = Array.isArray(res?.teams) ? res.teams : this.teamOptions;
          this.permissionsOptions = (() => {
            const permMap = new Map();
            ['subscriber', 'editor', 'administrator'].forEach(p => permMap.set(p.toLowerCase(), p));
            this.roles.forEach(r => {
              const val = String(r.permissions || '').trim();
              if (val) permMap.set(val.toLowerCase(), val);
            });
            return Array.from(permMap.values()).sort((a, b) => a.localeCompare(b));
          })();
          this.select(sel.email);
          this.savedAt = Date.now();
        } catch (e) {
          console.error(e);
          this.error = (e && e.message) ? e.message : 'Failed to save changes.';
        } finally {
          this.saving = false;
        }
      },

      formatPermission(p) {
        if (!p) return '(none)';
        return p.replace(/\b\w/g, c => c.toUpperCase());
      },

      timeAgo(ts) {
        if (!ts) return '';
        const diff = Math.max(0, Date.now() - ts);
        if (diff < 1000) return 'just now';
        const minutes = Math.floor(diff / 60000);
        if (minutes < 1) return 'just now';
        if (minutes < 60) return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours} hour${hours === 1 ? '' : 's'} ago`;
        const days = Math.floor(hours / 24);
        return `${days} day${days === 1 ? '' : 's'} ago`;
      },

      openNewMember() {
        this.newMember = { email: '', first: '', last: '', permissions: 'subscriber' };
        this.newMemberError = '';
        this.teamSelections = {};
        this.editTeam = '';
        this.showNewMemberModal = true;
        this.$nextTick(() => {
          try { this.$refs?.newMemberEmail?.focus(); } catch (_) {}
        });
      },

      closeNewMember() {
        if (this.newMemberSaving) return;
        this.showNewMemberModal = false;
      },

      async createMember() {
        if (this.newMemberSaving) return;
        const email = String(this.newMember.email || '').trim();
        const first = String(this.newMember.first || '').trim();
        const last = String(this.newMember.last || '').trim();
        if (!email) { this.newMemberError = 'Email is required.'; return; }
        if (!first) { this.newMemberError = 'First name is required.'; return; }
        if (!last) { this.newMemberError = 'Last name is required.'; return; }
        this.newMemberSaving = true;
        this.newMemberError = '';
        try {
          const payload = {
            email,
            first,
            last,
            permissions: this.newMember.permissions || '',
            team: '',
            role: '',
            spanish: ''
          };
          const res = await callRpc('addRoleEntry', payload);
          this.roles = Array.isArray(res?.items) ? res.items : this.roles;
          this.teamOptions = Array.isArray(res?.teams) ? res.teams : this.teamOptions;
          this.permissionsOptions = (() => {
            const permMap = new Map();
            ['subscriber', 'editor', 'administrator'].forEach(p => permMap.set(p.toLowerCase(), p));
            this.roles.forEach(r => {
              const val = String(r.permissions || '').trim();
              if (val) permMap.set(val.toLowerCase(), val);
            });
            return Array.from(permMap.values()).sort((a, b) => a.localeCompare(b));
          })();
          this.showNewMemberModal = false;
          this.select(email);
          this.savedAt = Date.now();
        } catch (e) {
          console.error(e);
          this.newMemberError = (e && e.message) ? e.message : 'Failed to add member.';
        } finally {
          this.newMemberSaving = false;
        }
      }
    };
  }
</script>
