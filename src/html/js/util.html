<script>
  function callRpc(method, payload) {
    return new Promise((resolve, reject) => {
      const runner = (window.google && google.script && google.script.run) || null;
      if (runner && runner.rpc) {
        runner
          .withSuccessHandler(resolve)
          .withFailureHandler(reject)
          .rpc({ method, payload });
        return;
      }

      const base = String(window.__BASE__ || '').replace(/\/+$/, '');
      if (!base) {
        reject(new Error('RPC endpoint is not configured.'));
        return;
      }

      const headers = Object.assign(
        { 'Content-Type': 'text/plain;charset=utf-8' },
        window.__RPC_HEADERS__ && typeof window.__RPC_HEADERS__ === 'object'
          ? window.__RPC_HEADERS__
          : {}
      );

      fetch(`${base}/exec`, {
        method: 'POST',
        mode: 'cors',
        credentials: 'omit',
        headers,
        body: JSON.stringify({ method, payload })
      })
        .then(async (res) => {
          let data = null;
          try { data = await res.json(); }
          catch (_) { throw new Error('Invalid RPC response'); }

          if (data && typeof data === 'object' && 'ok' in data) {
            if (data.ok) return data.data;
            throw new Error(data.error || 'RPC request failed');
          }
          return data;
        })
        .then(resolve)
        .catch((err) => reject(err));
    });
  }

  const forcedGuestFlag = (() => {
    try {
      const params = new URLSearchParams(window.location.search || '');
      const mode = String(params.get('mode') || params.get('view') || '').toLowerCase();
      return mode === 'guest';
    } catch (_) {
      return false;
    }
  })();

  const DEFAULT_CAPABILITIES = {
    canEditPlan: false,
    canEditSongs: false,
    canViewTeam: false,
    canManageTeams: false,
    canAdminAvailability: false
  };
  const DEFAULT_AUTH = {
    email: '',
    permissions: '',
    first: '',
    last: '',
    isAdmin: false,
    isLoggedIn: false,
    capabilities: { ...DEFAULT_CAPABILITIES },
    ready: false
  };

  const dispatchAuthChanged = (auth) => {
    try {
      document.dispatchEvent(new CustomEvent('app-auth-changed', { detail: auth }));
    } catch (_) { /* ignore */ }
  };

  function normalizeAuthState(profile, ready = false) {
    const raw = profile && typeof profile === 'object' ? profile : {};
    const capabilities = Object.assign({}, DEFAULT_CAPABILITIES, raw.capabilities || {});
    const normalized = Object.assign({}, DEFAULT_AUTH, raw, {
      capabilities,
      ready: ready || Boolean(raw.ready)
    });
    if (typeof normalized.isLoggedIn !== 'boolean') {
      normalized.isLoggedIn = Boolean(normalized.email);
    }
    if (typeof normalized.isAdmin !== 'boolean') {
      normalized.isAdmin = Boolean(capabilities.canManageTeams);
    }
    return normalized;
  }

  function setAuthState(profile, { ready = false } = {}) {
    const normalized = normalizeAuthState(profile, ready);
    window.__AUTH__ = normalized;
    window.__GUEST__ = Boolean(window.__FORCE_GUEST__ || forcedGuestFlag || !normalized.capabilities.canEditPlan);
    dispatchAuthChanged(normalized);
    return normalized;
  }

  async function refreshAuthContext() {
    try {
      const profile = await callRpc('getViewerProfile', null);
      return setAuthState(profile, { ready: true });
    } catch (err) {
      console.warn('Auth check failed', err);
      return setAuthState(window.__AUTH__ || DEFAULT_AUTH, { ready: false });
    }
  }

  window.__FORCE_GUEST__ = forcedGuestFlag;
  window.__AUTH__ = normalizeAuthState(typeof window.__VIEWER__ === 'object' ? window.__VIEWER__ : null, Boolean(window.__VIEWER__));
  window.__GUEST__ = Boolean(window.__FORCE_GUEST__ || !window.__AUTH__.capabilities.canEditPlan);
  dispatchAuthChanged(window.__AUTH__);
  refreshAuthContext();
  window.refreshAuthContext = refreshAuthContext;

  // Minimal toast-style notifier for consistent UX (client-only)
  function notify(message, type = 'info', ms = 2200) {
    try {
      const root = document.createElement('div');
      root.textContent = String(message ?? '');
      root.style.position = 'fixed';
      root.style.right = '12px';
      root.style.bottom = '12px';
      root.style.zIndex = '9999';
      root.style.maxWidth = '70vw';
      root.style.padding = '8px 12px';
      root.style.borderRadius = '6px';
      root.style.color = '#111827';
      root.style.background = type === 'error' ? '#fecaca' : type === 'success' ? '#bbf7d0' : '#e5e7eb';
      root.style.boxShadow = '0 4px 14px rgba(0,0,0,0.2)';
      document.body.appendChild(root);
      setTimeout(() => root.remove(), ms);
    } catch (_) {
      try { alert(String(message ?? '')); } catch(_) {}
    }
  }

  (function (global) {
    if (global && typeof global.songPreview === 'function') return;
    function normalizePreview(data) {
      if (!data || !data.hasSong) return { hasSong: false };
      return {
        hasSong: true,
        songName: data.song?.Song || data.songName || '(Untitled)',
        reason: data.song?.Reason || data.reason || '',
        leader: data.song?.Leader || data.leader || '',
        season: data.song?.Season || data.season || '',
        themes: data.song?.Themes || data.themes || '',
        scriptures: data.song?.Scriptures || data.scriptures || '',
        keywords: data.song?.Keywords || data.keywords || '',
        lyrics: data.song?.Lyrics || data.song?.['Lyrics (PD)'] || data.lyrics || '',
        aiReason: data.aiReason || '',
        additional: data.additional || '',
        showUse: !!data.isModalContext,
        onUse: typeof data.useSong === 'function' ? () => data.useSong() : null,
        onCopy: typeof data.onCopy === 'function'
          ? (evt) => data.onCopy(evt)
          : (typeof data.copyLyrics === 'function' ? (evt) => data.copyLyrics(evt) : null),
        link: data.song?.Link || data.link || '',
        showMedia: !!data.mediaFiles,
        mediaFiles: Array.isArray(data.mediaFiles) ? data.mediaFiles : [],
        mediaLoading: !!data.mediaLoading,
        mediaMessage: data.mediaMessage || 'No files in folder.',
        stats: {
          uses: data.stats?.uses || data.song?.Uses || '',
          usage: data.stats?.usage || data.song?.Usage || '',
          years: data.stats?.years || data.song?.Years_Used || '',
          lastUsed: data.stats?.lastUsed || data.song?.Last_Used || '',
          firstUsed: data.stats?.firstUsed || data.song?.First_Used || ''
        },
        folderUrl: data.song?._folderUrl || '',
        onOpenFolder: typeof data.openFolder === 'function' ? () => data.openFolder(data.song?._folderUrl) : null,
        starred: !!data.starred,
        onToggleStar: typeof data.onToggleStar === 'function' ? (evt) => data.onToggleStar(evt) : null
      };
    }
    global.songPreview = function songPreview(initial = {}) {
      return {
        preview: normalizePreview(initial),
        update(data) {
          this.preview = normalizePreview(data);
        }
      };
    };
  })(typeof window !== 'undefined' ? window : this);
</script>
